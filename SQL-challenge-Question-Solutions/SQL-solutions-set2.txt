Q51.
Column Name Type
name varchar
continent varchar
area int
population int
gdp int
name is the primary key column for this table.
Each row of this table gives information about the name of a country, the continent to which it
belongs, its area, the population, and its GDP value.
A country is big if:
● it has an area of at least three million (i.e., 3000000 km2), or
● it has a population of at least twenty-five million (i.e., 25000000).
Write an SQL query to report the name, population, and area of the big countries.
Return the result table in any order.
The query result format is in the following example.
Input:
World table:
name continent area population gdp
Afghanistan Asia 652230 25500100 20343000000
Albania Europe 28748 2831741 12960000000
Algeria Africa 2381741 37100000 188681000000
Andorra Europe 468 78115 3712000000
Angola Africa 1246700 20609294 100990000000
Output:
name population area
Afghanistan 25500100 652230
Algeria 37100000 2381741

ans-we can use the following SQL query to achieve the desired result:

```sql
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
```

This query selects the columns "name," "population," and "area" from the "World" table and filters the rows based on the specified conditions. It retrieves the information for countries that have an area of at least three million or a population of at least twenty-five million. The result is ordered in any order as requested.
Q52.
Table: Customer
Column Name Type
id int
name varchar
referee_id int
id is the primary key column for this table.
Each row of this table indicates the id of a customer, their name, and the id of the customer who
referred them.
Write an SQL query to report the names of the customer that are not referred by the customer with id
= 2.
Return the result table in any order.
The query result format is in the following example.
Input:
Customer table:
id name referee_id
1 Will null
2 Jane null
3 Alex 2
4 Bill null
5 Zack 1
6 Mark 2
Output:
name
Will
Jane
Bill
Zack

ans-we can use the following SQL query to achieve the desired result:

```sql
SELECT name
FROM Customer
WHERE referee_id IS NULL OR referee_id <> 2;
```

This query selects the "name" column from the "Customer" table and filters the rows based on the condition that the "referee_id" is either NULL (indicating that there is no referee) or it's not equal to 2 (indicating that the customer was not referred by the customer with id = 2). The result is ordered in any order as requested.
Q53.
Table: Customers
Column Name Type
id int
name varchar
id is the primary key column for this table.
Each row of this table indicates the ID and name of a customer.
Table: Orders
Column Name Type
id int
customerId int
id is the primary key column for this table.
customerId is a foreign key of the ID from the Customers table.
Each row of this table indicates the ID of an order and the ID of the customer who ordered it.
Write an SQL query to report all customers who never order anything.
Return the result table in any order.
The query result format is in the following example.
Input:
Customers table:
id name
1 Joe
2 Henry
3 Sam
4 Max
Orders table:
id customerId
1 3
2 1
Output:
Customers
Henry
Max

ans-To find all customers who never placed an order, you can use a LEFT JOIN to match the Customers table with the Orders table and filter out the rows where there is no corresponding order. Here's the SQL query:

sql
SELECT c.name AS Customers
FROM Customers c
LEFT JOIN Orders o ON c.id = o.customerId
WHERE o.id IS NULL;
This query retrieves the names of customers from the Customers table who do not have corresponding entries in the Orders table. It uses a LEFT JOIN to combine the two tables based on the customer IDs and then filters out the rows where there is no matching order (o.id IS NULL).
Q54.
Table: Employee
Column Name Type
employee_id int
team_id int
employee_id is the primary key for this table.
Each row of this table contains the ID of each employee and their respective team.
Write an SQL query to find the team size of each of the employees.
Return result table in any order.
The query result format is in the following example.
Input:
Employee Table:
employee_id team_id
1 8
2 8
3 8
4 7
5 9
6 9
Output:
employee_id team_size
1 3
2 3
3 3
4 1
5 2
6 2
Explanation:
Employees with Id 1,2,3 are part of a team with team_id = 8.
Employee with Id 4 is part of a team with team_id = 7.
Employees with Id 5,6 are part of a team with team_id = 9.

ans-To find the team size of each employee, you can use a subquery within a JOIN operation. The subquery calculates the team size for each team, and then the main query joins the Employee table with this subquery based on the team_id. Here's the SQL query:

sql

SELECT e.employee_id, t.team_size
FROM Employee e
JOIN (
    SELECT team_id, COUNT(employee_id) AS team_size
    FROM Employee
    GROUP BY team_id
) t ON e.team_id = t.team_id;
This query calculates the team size for each team using a subquery that groups the Employee table by team_id and counts the number of employees in each team. Then, the main query joins the Employee table with this subquery based on the team_id and retrieves the employee_id and the corresponding team_size.





Q55
Table Person:
Column Name Type
id int
name varchar
phone_number varchar
id is the primary key for this table.
Each row of this table contains the name of a person and their phone number.
Phone number will be in the form 'xxx-yyyyyyy' where xxx is the country code (3 characters) and
yyyyyyy is the phone number (7 characters) where x and y are digits. Both can contain leading zeros.
Table Country:
Column Name Type
name varchar
country_code varchar
country_code is the primary key for this table.
Each row of this table contains the country name and its code. country_code will be in the form 'xxx'
where x is digits.
Table Calls:
Column Name Type
caller_id int
callee_id int
duration int
There is no primary key for this table, it may contain duplicates.
Each row of this table contains the caller id, caller id and the duration of the call in minutes. caller_id
!= callee_id
A telecommunications company wants to invest in new countries. The company intends to invest in
the countries where the average call duration of the calls in this country is strictly greater than the
global average call duration.
Write an SQL query to find the countries where this company can invest.
Return the result table in any order.
The query result format is in the following example.
Input:
Person table:
id name phone_number
3 Jonathan 051-1234567
12 Elvis 051-7654321
1 Moncef 212-1234567
2 Maroua 212-6523651
7 Meir 972-1234567
9 Rachel 972-0011100
Country table:
name country_code
Peru 51
Israel 972
Morocco 212
Germany 49
Ethiopia 251
Calls table:
caller_id callee_id duration
1 9 33
2 9 4
1 2 59
3 12 102
3 12 330
12 3 5
7 9 13
7 1 3
9 7 1
1 7 7
Output:
country
Peru
Explanation:
The average call duration for Peru is (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667
The average call duration for Israel is (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500
The average call duration for Morocco is (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000
Global call duration average = (2 * (33 + 4 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000
Since Peru is the only country where the average call duration is greater than the global average, it is
the only recommended country.
ans-To find the countries where the company can invest based on the average call duration, we can use the following SQL query:

```sql
SELECT c.name AS country
FROM Country c
JOIN Person p ON c.country_code = SUBSTR(p.phone_number, 1, 3)
JOIN Calls ca ON p.id = ca.caller_id OR p.id = ca.callee_id
GROUP BY c.name
HAVING AVG(ca.duration) > (
    SELECT AVG(duration) * 2
    FROM Calls
);
```

Explanation of the query:

1. The `SELECT` statement selects the country name from the `Country` table.
2. The `JOIN` clauses connect the `Country` table with the `Person` and `Calls` tables using the country code and caller/callee IDs.
3. The `GROUP BY` clause groups the records by country name.
4. The `HAVING` clause filters out the countries where the average call duration is greater than twice the global average call duration.
5. The subquery `(SELECT AVG(duration) * 2 FROM Calls)` calculates the global average call duration and doubles it.
6. The result is a list of countries where the company can invest based on the given criteria.

This query will return the desired result with the countries where the company can invest based on the average call duration.
Q56.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the device that is first logged in for each player.
Return the result table in any order.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-05-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
player_id device_id
1 2
2 3
3 1
ans-To find the device that is first logged in for each player, we can use the following SQL query:

```sql
SELECT player_id, MIN(device_id) AS device_id
FROM Activity
GROUP BY player_id;
```

Explanation of the query:

1. The `SELECT` statement selects the `player_id` and the minimum `device_id` for each player.
2. The `FROM` clause specifies the `Activity` table.
3. The `GROUP BY` clause groups the records by `player_id`.
4. The `MIN(device_id)` function calculates the minimum value of `device_id` for each group (player).
5. The result is a list of `player_id` and the corresponding first logged-in `device_id` for each player.

This query will return the desired result where each row represents the player and the device that was first logged in.
Q57.
Table: Orders
Column Name Type
order_number int
customer_number int
order_number is the primary key for this table.
This table contains information about the order ID and the customer ID.
Write an SQL query to find the customer_number for the customer who has placed the largest
number of orders.
The test cases are generated so that exactly one customer will have placed more orders than any
other customer.
The query result format is in the following example.
Input:
Orders table:
order_number customer_numbe
1 1
2 2
3 3
4 3
Output:
customer_number
3
Explanation:
The customer with number 3 has two orders, which is greater than either customer 1 or 2 because
each of them only has one order.
So the result is customer_number 3.
Follow up: What if more than one customer has the largest number of orders, can you find all the
customer_number in this case?
ans-To find the customer_number for the customer who has placed the largest number of orders, we can use the following SQL query:

```sql
SELECT customer_number
FROM Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;
```

Explanation of the query:

1. The `SELECT` statement selects the `customer_number` from the `Orders` table.
2. The `GROUP BY` clause groups the orders by `customer_number`.
3. The `COUNT(*)` function counts the number of orders for each customer.
4. The `ORDER BY` clause sorts the groups in descending order based on the count of orders.
5. The `LIMIT 1` clause returns only the first row, which will be the customer with the largest number of orders.

If there is more than one customer with the largest number of orders and we want to find all of them, you can modify the query slightly as follows:

```sql
SELECT customer_number
FROM Orders
GROUP BY customer_number
HAVING COUNT(*) = (
    SELECT MAX(order_count)
    FROM (
        SELECT COUNT(*) AS order_count
        FROM Orders
        GROUP BY customer_number
    ) AS order_counts
);
```

Explanation of the modified query:

1. The outer query selects the `customer_number` from the `Orders` table.
2. The `GROUP BY` clause groups the orders by `customer_number`.
3. The `HAVING` clause filters the groups where the count of orders is equal to the maximum count of orders.
4. The subquery `(SELECT COUNT(*) AS order_count FROM Orders GROUP BY customer_number) AS order_counts` calculates the count of orders for each customer and gives it an alias.
5. The subquery `(SELECT MAX(order_count) FROM ...) as order_counts` calculates the maximum count of orders across all customers.
6. The result is a list of `customer_number` values for all customers who have the largest number of orders.

This modified query will give you the customer_number(s) for all customers who have placed the largest number of orders.
Q58.
Table: Cinema
Column Name Type
seat_id int
free bool
seat_id is an auto-increment primary key column for this table.
Each row of this table indicates whether the ith seat is free or not. 1 means free while 0 means
occupied.
Write an SQL query to report all the consecutive available seats in the cinema.
Return the result table ordered by seat_id in ascending order.
The test cases are generated so that more than two seats are consecutively available.
The query result format is in the following example.
Input:
Cinema table:
seat_id free
1 1
2 0
3 1
4 1
5 1
Output:
seat_id
3
4
5
ans-we can use the following SQL query to report all the consecutive available seats in the cinema:

```sql
SELECT DISTINCT c1.seat_id
FROM Cinema c1
JOIN Cinema c2 ON c1.seat_id + 1 = c2.seat_id
WHERE c1.free = 1 AND c2.free = 1;
```

Explanation of the query:

1. The `SELECT` statement selects the `seat_id` column from the `Cinema` table.
2. The query performs a self-join on the `Cinema` table using aliases `c1` and `c2`.
3. The join condition `c1.seat_id + 1 = c2.seat_id` checks if two consecutive seats are available (both have a value of 1 for the `free` column).
4. The `WHERE` clause filters the rows where both `c1` and `c2` seats are free.
5. The `DISTINCT` keyword ensures that only distinct `seat_id` values are returned.
6. The result is a list of `seat_id` values representing consecutive available seats.

This query will give you the desired output by reporting the consecutive available seats in the cinema, ordered by `seat_id` in ascending order.
Q59.
Table: SalesPerson
Column Name Type
sales_id int
name varchar
salary int
commission_rate int
hire_date date
sales_id is the primary key column for this table.
Each row of this table indicates the name and the ID of a salesperson alongside their salary,
commission rate, and hire date.
Table: Company
Column Name Type
com_id int
name varchar
city varchar
com_id is the primary key column for this table.
Each row of this table indicates the name and the ID of a company and the city in which the company
is located.
Table: Orders
Column Name Type
order_id int
order_date date
com_id int
sales_id int
amount int
order_id is the primary key column for this table.
com_id is a foreign key to com_id from the Company table.
sales_id is a foreign key to sales_id from the SalesPerson table.
Each row of this table contains information about one order. This includes the ID of the company, the
ID of the salesperson, the date of the order, and the amount paid.
Write an SQL query to report the names of all the salespersons who did not have any orders related to
the company with the name "RED".
Return the result table in any order.
The query result format is in the following example.
Input:
SalesPerson table:
sales_id name salary commission_rate hire_date
1 John 100000 6 4/1/2006
2 Amy 12000 5 5/1/2010
3 Mark 65000 12 12/25/2008
4 Pam 25000 25 1/1/2005
5 Alex 5000 10 2/3/2007
Company table:
com_id name city
1 RED Boston
2 ORANGE New York
3 YELLOW Boston
4 GREEN Austin
Orders table:
order_id order_date com_id sales_id amount
1 1/1/2014 3 4 10000
2 2/1/2014 4 5 5000
3 3/1/2014 1 1 50000
4 4/1/2014 1 4 25000
Output:
name
Amy
Mark
Alex
Explanation:
According to orders 3 and 4 in the Orders table, it is easy to tell that only salesperson John and Pam
have sales to company RED, so we report all the other names in the table salesperson.
ans-we can use the following SQL query to retrieve the names of all salespersons who did not have any orders related to the company with the name "RED":

```sql
SELECT s.name
FROM SalesPerson s
LEFT JOIN Orders o ON s.sales_id = o.sales_id
LEFT JOIN Company c ON o.com_id = c.com_id
WHERE c.name != 'RED' OR c.name IS NULL;
```

Explanation of the query:

1. The `SELECT` statement selects the `name` column from the `SalesPerson` table.
2. The query uses a `LEFT JOIN` to join the `SalesPerson` table with the `Orders` table based on the `sales_id` column.
3. Another `LEFT JOIN` is used to join the `Orders` table with the `Company` table based on the `com_id` column.
4. The `WHERE` clause filters out the rows where the company name is "RED" or where there is no matching company name (using `IS NULL`).
5. The result is a list of names of salespersons who did not have any orders related to the company with the name "RED".

This query will give you the desired output by reporting the names of salespersons who did not have any orders related to the company named "RED".
Q60.
Table: Triangle
Column Name Type
x int
y int
z int
(x, y, z) is the primary key column for this table.
Each row of this table contains the lengths of three line segments.
Write an SQL query to report for every three line segments whether they can form a triangle.
Return the result table in any order.
The query result format is in the following example.
Input:
Triangle table:
x y z
13 15 30
10 20 15
Output:
x y z triangle
13 15 30 No
10 20 15 Yes
ans-To determine whether a set of three line segments can form a triangle, we can use the triangle inequality theorem, which states that the sum of the lengths of any two sides of a triangle must be greater than the length of the third side. You can use this theorem to create an SQL query as follows:

```sql
SELECT x, y, z,
       CASE
           WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
           ELSE 'No'
       END AS triangle
FROM Triangle;
```

Explanation of the query:

1. The `SELECT` statement selects the columns `x`, `y`, and `z` from the `Triangle` table.
2. The `CASE` expression checks whether the sum of any two sides of the triangle is greater than the length of the third side for each row. If all three inequalities are satisfied, the result is 'Yes', indicating that the sides can form a triangle. Otherwise, the result is 'No'.
3. The `END` keyword marks the end of the `CASE` expression.
4. The query returns the original sides and the result of the triangle check for each row in the `Triangle` table.

This query will help you determine whether each set of three line segments can form a triangle or not.
Q61.
Table: Point
Column Name Type
x int
x is the primary key column for this table.
Each row of this table indicates the position of a point on the X-axis.
Write an SQL query to report the shortest distance between any two points from the Point table.
The query result format is in the following example.
Input:
Point table:
x
-1
0
2
Output:
shortest
1
Explanation:
The shortest distance is between points -1 and 0 which is |(-1) - 0| = 1.
Follow up: How could you optimise your query if the Point table is ordered in ascending order?
ans-To find the shortest distance between any two points in the `Point` table, we can use the following SQL query:

```sql
SELECT MIN(ABS(p1.x - p2.x)) AS shortest
FROM Point p1
CROSS JOIN Point p2
WHERE p1.x <> p2.x;
```

Explanation of the query:

1. The `SELECT` statement calculates the absolute difference between the `x` values of all possible pairs of points using the `ABS` function and then selects the minimum value using `MIN`.
2. The `CROSS JOIN` combines every row from `Point` table `p1` with every row from `Point` table `p2`, generating all possible pairs of points.
3. The `WHERE` clause filters out pairs where the `x` values are the same to avoid calculating the distance between the same point.
4. The result is the shortest distance between any two distinct points.

Regarding the follow-up question, if the `Point` table is ordered in ascending order, you can optimize the query by reducing the number of comparisons:

```sql
SELECT MIN(LEAST(LEAD(x) OVER (ORDER BY x) - x, x - LAG(x) OVER (ORDER BY x))) AS shortest
FROM Point;
```

Explanation of the optimized query:

1. The `LEAD` function gets the `x` value of the next row, and the `LAG` function gets the `x` value of the previous row, ordered by `x`.
2. The `LEAST` function returns the smallest value among the difference between the next point's `x` and the current point's `x`, and the difference between the current point's `x` and the previous point's `x`.
3. The `MIN` function then selects the minimum of these smallest differences, which represents the shortest distance between consecutive points.

This optimized query leverages the ordering of the `Point` table to calculate the shortest distance efficiently.
Q62.
Table: ActorDirector
Column Name Type
actor_id int
director_id int
timestamp int
timestamp is the primary key column for this table.
Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor has
cooperated with the director at least three times.
Return the result table in any order.
The query result format is in the following example.
Input:
ActorDirector table:
actor_id director_id timestamp
1 1 0
1 1 1
1 1 2
1 2 3
1 2 4
2 1 5
2 1 6
Output:
actor_id director_id
1 1
Explanation:
The only pair is (1, 1) where they cooperated exactly 3 times.
ans-To find pairs of `(actor_id, director_id)` where the actor has cooperated with the director at least three times, we can use the following SQL query:

```sql
SELECT actor_id, director_id
FROM ActorDirector
GROUP BY actor_id, director_id
HAVING COUNT(*) >= 3;
```

Explanation of the query:

1. The `SELECT` statement retrieves `actor_id` and `director_id` pairs from the `ActorDirector` table.
2. The `GROUP BY` clause groups the rows in the table by `actor_id` and `director_id`.
3. The `HAVING` clause filters the grouped results to include only those pairs where the count of records (i.e., cooperation times) is greater than or equal to 3.

This query should provide you with the desired output, showing pairs of `(actor_id, director_id)` where the actor has cooperated with the director at least three times.
Q63.
Table: Sales
Column Name Type
sale_id int
product_id int
year int
quantity int
price int
(sale_id, year) is the primary key of this table.
product_id is a foreign key to the Product table.
Each row of this table shows a sale on the product product_id in a certain year.
Note that the price is per unit.
Table: Product
Column Name Type
product_id int
product_name varchar
product_id is the primary key of this table.
Each row of this table indicates the product name of each product.
Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.
Return the resulting table in any order.
The query result format is in the following example.
Input:
Sales table:
sale_id product_id year quantity price
1 100 2008 10 5000
2 100 2009 12 5000
7 200 2011 15 9000
Product table:
product_id product_name
100 Nokia
200 Apple
300 Samsung
Output:
product_name year price
Nokia 2008 5000
Nokia 2009 5000
Apple 2011 9000
Explanation:
From sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.
From sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.
From sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.
ans-To retrieve the product_name, year, and price for each sale_id in the Sales table, we can use the following SQL query:

```sql
SELECT p.product_name, s.year, s.price
FROM Sales s
JOIN Product p ON s.product_id = p.product_id;
```

Explanation of the query:

1. The `SELECT` statement retrieves data from the `Sales` and `Product` tables to get the product_name, year, and price for each sale.
2. The `JOIN` clause combines the `Sales` and `Product` tables based on the `product_id` column.
3. The query retrieves the product_name from the `Product` table and the year and price from the `Sales` table based on the matching `product_id`.

This query should provide you with the desired output, showing the product_name, year, and price for each sale_id in the Sales table.
Q64.
Table: Project
Column Name Type
project_id int
employee_id int
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to the Employee table.
Each row of this table indicates that the employee with employee_id is working on the project with
project_id.
Table: Employee
Column Name Type
employee_id int
name varchar
experience_years int
employee_id is the primary key of this table.
Each row of this table contains information about one employee.
Write an SQL query that reports the average experience years of all the employees for each project,
rounded to 2 digits.
Return the result table in any order.
The query result format is in the following example.
Input:
Project table:
project_id employee_id
1 1
1 2
1 3
2 1
2 4
Employee table:
employee_id name experience_years
1 Khaled 3
2 Ali 2
3 John 1
4 Doe 2
Output:
project_id average_years
1 2
2 2.5
Explanation:
The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is
(3 + 2) / 2 = 2.50
ans-To calculate the average experience years of all employees for each project, we can use the following SQL query:

```sql
SELECT
    p.project_id,
    ROUND(AVG(e.experience_years), 2) AS average_years
FROM Project p
JOIN Employee e ON p.employee_id = e.employee_id
GROUP BY p.project_id;
```

Explanation of the query:

1. The `SELECT` statement retrieves data from the tables `Project` and `Employee` and calculates the average experience years for each project.
2. The `JOIN` clause combines the `Project` and `Employee` tables based on the `employee_id` column.
3. The `AVG()` aggregate function calculates the average experience years of all employees for each project.
4. The `ROUND()` function rounds the average experience years to 2 decimal places.
5. The `GROUP BY` clause groups the results by `project_id`, so the average is calculated for each project separately.

This query should provide you with the desired output, showing the average experience years for each project.
Q65.
Table: Product
Column Name Type
product_id int
product_name varchar
unit_price int
product_id is the primary key of this table.
Each row of this table indicates the name and the price of each product.
Table: Sales
Column Name Type
seller_id int
product_id int
buyer_id int
sale_date date
quantity int
price int
This table has no primary key, it can have repeated rows.
product_id is a foreign key to the Product table.
Each row of this table contains some information about one sale.
Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.
Return the result table in any order.
The query result format is in the following example.
Input:
Product table:
product_id product_name unit_price
1 S8 1000
2 G4 800
3 iPhone 1400
Sales table:
seller_id product_id buyer_id sale_date quantity price
1 1 1 2019-01-21 2 2000
1 2 2 2019-02-17 1 800
2 2 3 2019-06-02 1 800
3 3 4 2019-05-13 2 2800
Output:
seller_id
1
3
Explanation: Both sellers with id 1 and 3 sold products with the most total price of 2800.
ans-To find the best sellers by total sales price, we can use a combination of subqueries and the `RANK()` window function to handle ties. Here's the SQL query to achieve this:

```sql
WITH SellerTotalSales AS (
    SELECT
        seller_id,
        SUM(price * quantity) AS total_sales
    FROM Sales
    GROUP BY seller_id
),
RankedSellers AS (
    SELECT
        seller_id,
        total_sales,
        RANK() OVER (ORDER BY total_sales DESC) AS rank
    FROM SellerTotalSales
)
SELECT seller_id
FROM RankedSellers
WHERE rank = 1;
```

Explanation of the query:

1. The `SellerTotalSales` common table expression calculates the total sales for each seller by summing up the product of `price` and `quantity` in the `Sales` table.
2. The `RankedSellers` common table expression assigns a rank to each seller based on their total sales in descending order using the `RANK()` window function.
3. The main query selects the `seller_id` from the `RankedSellers` table where the rank is equal to 1. This retrieves the best sellers (top-ranked sellers) by total sales price.

This query should give you the desired output, listing the seller(s) with the highest total sales price. If there is a tie for the best seller(s), all tied sellers will be included in the result.
Q66.
Table: Product
Column Name Type
product_id int
product_name varchar
unit_price int
product_id is the primary key of this table.
Each row of this table indicates the name and the price of each product.
Table: Sales
Column Name Type
seller_id int
product_id int
buyer_id int
sale_date date
quantity int
price int
This table has no primary key, it can have repeated rows.
product_id is a foreign key to the Product table.
Each row of this table contains some information about one sale.
Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and
iPhone are products present in the Product table.
Return the result table in any order.
The query result format is in the following example.
Input:
Product table:
product_id product_name unit_price
1 S8 1000
2 G4 800
3 iPhone 1400
Sales table:
seller_id product_id buyer_id sale_date quantity price
1 1 1 2019-01-21 2 2000
1 2 2 2019-02-17 1 800
2 1 3 2019-06-02 1 800
3 3 3 2019-05-13 2 2800
Output:
buyer_id
1
Explanation:
The buyer with id 1 bought an S8 but did not buy an iPhone. The buyer with id 3 bought both.
Orders table:
order_id book_id quantity dispatch_date
1 1 2 2018-07-26
2 1 1 2018-11-05
3 3 8 2019-06-11
4 4 6 2019-06-05
5 4 5 2019-06-20
6 5 9 2009-02-02
7 5 8 2010-04-13
Output:
book_id name
1 "Kalila And Demna"
2 "28 Letters"
5 "The Hunger Games"
ans-To find the buyers who have bought the product "S8" but not "iPhone", we can use a combination of subqueries and the `NOT IN` clause. Here's the SQL query to achieve this:

```sql
SELECT DISTINCT buyer_id
FROM Sales
WHERE product_id = (
    SELECT product_id
    FROM Product
    WHERE product_name = 'S8'
) AND buyer_id NOT IN (
    SELECT buyer_id
    FROM Sales
    WHERE product_id = (
        SELECT product_id
        FROM Product
        WHERE product_name = 'iPhone'
    )
);
```

Explanation of the query:

1. The first subquery retrieves the `product_id` for the product named 'S8' from the `Product` table.
2. The main query selects distinct `buyer_id` from the `Sales` table where the `product_id` matches the one obtained from the subquery in step 1.
3. The second subquery retrieves the `product_id` for the product named 'iPhone' from the `Product` table.
4. The `NOT IN` clause filters out the `buyer_id` values that have also bought the product named 'iPhone'.

This query should give you the desired output, listing the buyers who bought the product 'S8' but not 'iPhone'.
Q67.
Table: Customer
Column Name Type
customer_id int
name varchar
visited_on date
amount int
(customer_id, visited_on) is the primary key for this table.
This table contains data about customer transactions in a restaurant.
visited_on is the date on which the customer with ID (customer_id) has visited the restaurant.
amount is the total paid by a customer.
You are the restaurant owner and you want to analyse a possible expansion (there will be at least one
customer every day).
Write an SQL query to compute the moving average of how much the customer paid in a seven days
window (i.e., current day + 6 days before). average_amount should be rounded to two decimal places.
Return result table ordered by visited_on in ascending order.
The query result format is in the following example.
Input:
Customer table:
customer_id name visited_on amount
1 Jhon 2019-01-01 100
2 Daniel 2019-01-02 110
3 Jade 2019-01-03 120
4 Khaled 2019-01-04 130
5 Winston 2019-01-05 110
6 Elvis 2019-01-06 140
7 Anna 2019-01-07 150
8 Maria 2019-01-08 80
9 Jaze 2019-01-09 110
1 Jhon 2019-01-10 130
3 Jade 2019-01-10 150
Output:
visited_on amount average_amount
2019-01-07 860 122.86
2019-01-08 840 120
2019-01-09 840 120
2019-01-10 1000 142.86
Explanation:
1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 +
130 + 110 + 140 + 150)/7 = 122.86
2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 +
110 + 140 + 150 + 80)/7 = 120
3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 +
140 + 150 + 80 + 110)/7 = 120
4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 +
150 + 80 + 110 + 130 + 150)/7 = 142.86
ans-we can calculate the moving average using a self-join along with the `AVG` window function to calculate the average over a 7-day window. Here's the SQL query to achieve this:

```sql
SELECT c.visited_on, 
       SUM(c1.amount) AS amount, 
       ROUND(AVG(c1.amount) OVER (ORDER BY c1.visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS average_amount
FROM Customer c
JOIN Customer c1
ON c.visited_on BETWEEN c1.visited_on AND DATE_ADD(c1.visited_on, INTERVAL 6 DAY)
GROUP BY c.visited_on
ORDER BY c.visited_on;
```

Explanation of the query:

1. The `SELECT` statement selects `visited_on`, the sum of `amount` over the 7-day window, and the moving average calculated using the `AVG` window function.
2. The `FROM` clause specifies the `Customer` table as `c` and performs a self-join with `Customer` table as `c1`.
3. The `JOIN` condition ensures that for each `visited_on` in the `c` table, it joins with the rows in the `c1` table that fall within a 7-day window (including the current day).
4. The `GROUP BY` clause groups the result by `visited_on`.
5. The `ORDER BY` clause orders the result by `visited_on`.
6. The `AVG` window function calculates the average over the 7-day window (including the current day) for the `amount` column.
7. The `ROUND` function rounds the calculated average to two decimal places.

This query should provide you with the desired output, showing the moving average of the amount for each day within a 7-day window. Adjust the query syntax to match your specific SQL database system if needed.
Q68.
Table: Scores
Column Name Type
player_name varchar
gender varchar
day date
score_points int
(gender, day) is the primary key for this table.
A competition is held between the female team and the male team.
Each row of this table indicates that a player_name and with gender has scored score_point in
someday.
Gender is 'F' if the player is in the female team and 'M' if the player is in the male team.
Write an SQL query to find the total score for each gender on each day.
Return the result table ordered by gender and day in ascending order.
The query result format is in the following example.
Input:
Scores table:
player_name gender day score_points
Aron F 2020-01-01 17
Alice F 2020-01-07 23
Bajrang M 2020-01-07 7
Khali M 2019-12-25 11
Slaman M 2019-12-30 13
Joe M 2019-12-31 3
Jose M 2019-12-18 2
Priya F 2019-12-31 23
Priyanka F 2019-12-30 17
Output:
gender day total
F 2019-12-30 17
F 2019-12-31 40
F 2020-01-01 57
F 2020-01-07 80
M 2019-12-18 2
M 2019-12-25 13
M 2019-12-30 26
M 2019-12-31 29
M 2020-01-07 36
Explanation:
For the female team:
The first day is 2019-12-30, Priyanka scored 17 points and the total score for the team is 17.
The second day is 2019-12-31, Priya scored 23 points and the total score for the team is 40.
The third day is 2020-01-01, Aron scored 17 points and the total score for the team is 57.
The fourth day is 2020-01-07, Alice scored 23 points and the total score for the team is 80.
For the male team:
The first day is 2019-12-18, Jose scored 2 points and the total score for the team is 2.
The second day is 2019-12-25, Khali scored 11 points and the total score for the team is 13.
The third day is 2019-12-30, Slaman scored 13 points and the total score for the team is 26.
The fourth day is 2019-12-31, Joe scored 3 points and the total score for the team is 29.
The fifth day is 2020-01-07, Bajrang scored 7 points and the total score for the team is 36.
ans-we can achieve this by using the `SUM` function with a `GROUP BY` clause to calculate the total score for each gender on each day. Here's the SQL query:

```sql
SELECT gender, day, SUM(score_points) AS total
FROM Scores
GROUP BY gender, day
ORDER BY gender, day;
```

Explanation of the query:

1. The `SELECT` statement selects the `gender`, `day`, and the sum of `score_points` for each group.
2. The `FROM` clause specifies the `Scores` table.
3. The `GROUP BY` clause groups the rows by `gender` and `day`.
4. The `SUM` function calculates the total score (`score_points`) for each group.
5. The `ORDER BY` clause orders the result by `gender` and `day` in ascending order.

This query should give you the desired output with the total score for each gender on each day, ordered by gender and day. Make sure to adjust the query syntax to match your specific SQL database system if needed.
Q69.
Table: Logs
Column Name Type
log_id int
log_id is the primary key for this table.
Each row of this table contains the ID in a log Table.
Write an SQL query to find the start and end number of continuous ranges in the table Logs.
Return the result table ordered by start_id.
The query result format is in the following example.
Input:
Logs table:
log_id
1
2
3
7
8
10
Output:
start_id end_id
1 3
7 8
10 10
Explanation:
The result table should contain all ranges in table Logs.
From 1 to 3 is contained in the table.
From 4 to 6 is missing in the table
From 7 to 8 is contained in the table.
Number 9 is missing from the table.
Number 10 is contained in the table.
ans-To find the start and end numbers of continuous ranges in the `Logs` table,we can use a self-join to identify gaps between consecutive log IDs. Here's the SQL query:

```sql
SELECT MIN(l1.log_id) AS start_id,
       CASE WHEN MIN(l2.log_id) IS NULL THEN MIN(l1.log_id)
            ELSE MIN(l2.log_id) - 1 END AS end_id
FROM Logs l1
LEFT JOIN Logs l2 ON l1.log_id + 1 = l2.log_id
GROUP BY l1.log_id
ORDER BY start_id;
```

Explanation of the query:

1. The `LEFT JOIN` between `Logs` table (aliased as `l1`) and itself (aliased as `l2`) is used to find consecutive log IDs.
2. The `ON` condition checks if the `log_id` in `l2` is one greater than the `log_id` in `l1`, indicating a continuous range.
3. The `GROUP BY` clause groups the result by the `log_id` in `l1`.
4. The `MIN` function is used to select the minimum `log_id` in `l1` for each group, representing the start of a range.
5. In the `CASE` statement, if the minimum `log_id` in the next group (`l2`) is not found, the end of the range is the same as the start (`MIN(l1.log_id)`). Otherwise, the end of the range is one less than the minimum `log_id` in the next group (`MIN(l2.log_id) - 1`).
6. The final result is ordered by `start_id`.

This query should provide the desired output showing the start and end numbers of continuous ranges in the `Logs` table. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q70.
Table: Students
Column Name Type
student_id int
student_name varchar
student_id is the primary key for this table.
Each row of this table contains the ID and the name of one student in the school.
Table: Subjects
Column Name Type
subject_name varchar
subject_name is the primary key for this table.
Each row of this table contains the name of one subject in the school.
Table: Examinations
Column Name Type
student_id int
subject_name varchar
There is no primary key for this table. It may contain duplicates.
Each student from the Students table takes every course from the Subjects table.
Each row of this table indicates that a student with ID student_id attended the exam of subject_name.
Write an SQL query to find the number of times each student attended each exam.
Return the result table ordered by student_id and subject_name.
The query result format is in the following example.
Input:
Students table:
student_id student_name
1 Alice
2 Bob
13 John
6 Alex
Subjects table:
subject_name
Math
Physics
Programming
Examinations table:
student_id subject_name
1 Math
1 Physics
1 Programming
2 Programming
1 Physics
1 Math
13 Math
13 Programming
13 Physics
2 Math
1 Math
Output:
student_id student_name subject_name attended_exams
1 Alice Math 3
1 Alice Physics 2
1 Alice Programming 1
2 Bob Math 1
2 Bob Physics 0
2 Bob Programming 1
6 Alex Math 0
6 Alex Physics 0
6 Alex Programming 0
13 John Math 1
13 John Physics 1
13 John Programming 1
Explanation:
The result table should contain all students and all subjects.
Alice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.
Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics
exam.
Alex did not attend any exams.
John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.
ans-To find the number of times each student attended each exam, including cases where a student did not attend an exam,we can use a Cartesian product between the Students and Subjects tables to create a combination of all students and all subjects, and then left join it with the Examinations table to count the attended exams. Here's the SQL query:

```sql
SELECT s.student_id, s.student_name, sb.subject_name,
       COALESCE(COUNT(e.subject_name), 0) AS attended_exams
FROM Students s
CROSS JOIN Subjects sb
LEFT JOIN Examinations e ON s.student_id = e.student_id AND sb.subject_name = e.subject_name
GROUP BY s.student_id, s.student_name, sb.subject_name
ORDER BY s.student_id, sb.subject_name;
```

Explanation of the query:

1. The `CROSS JOIN` between Students and Subjects tables creates a Cartesian product, generating all possible combinations of students and subjects.
2. The `LEFT JOIN` with the Examinations table is used to match students and subjects with the examinations they attended.
3. The `COALESCE` function is used to count the number of attended exams. If there is no match in the Examinations table, it returns 0.
4. The `GROUP BY` clause groups the result by student_id, student_name, and subject_name.
5. The final `SELECT` statement retrieves the student_id, student_name, subject_name, and attended_exams columns, ordered by student_id and subject_name.

This query should provide the desired output showing the number of times each student attended each exam, including cases where a student did not attend an exam. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q71.
Table: Employees
Column Name Type
employee_id int
employee_name varchar
manager_id int
employee_id is the primary key for this table.
Each row of this table indicates that the employee with ID employee_id and name employee_name
reports his work to his/her direct manager with manager_id
The head of the company is the employee with employee_id = 1.
Write an SQL query to find employee_id of all employees that directly or indirectly report their work to
the head of the company.
The indirect relation between managers will not exceed three managers as the company is small.
Return the result table in any order.
The query result format is in the following example.
Input:
Employees table:
employee_id
employee_nam
e manager_id
1 Boss 1
3 Alice 3
2 Bob 1
4 Daniel 2
7 Luis 4
8 Jhon 3
9 Angela 8
77 Robert 1
Output:
employee_id
2
77
4
7
Explanation:
The head of the company is the employee with employee_id 1.
The employees with employee_id 2 and 77 report their work directly to the head of the company.
The employee with employee_id 4 reports their work indirectly to the head of the company 4 --> 2 --> 1.
The employee with employee_id 7 reports their work indirectly to the head of the company 7 --> 4 --> 2
--> 1.
The employees with employee_id 3, 8, and 9 do not report their work to the head of the company
directly or indirectly.
ans-To find the `employee_id` of all employees who directly or indirectly report their work to the head of the company (employee with `employee_id` 1), we can use a recursive common table expression (CTE) in SQL. Here's the query:

```sql
WITH RecursiveEmployeeCTE AS (
    SELECT employee_id, manager_id
    FROM Employees
    WHERE manager_id = 1
    UNION ALL
    SELECT e.employee_id, e.manager_id
    FROM Employees e
    INNER JOIN RecursiveEmployeeCTE r ON e.manager_id = r.employee_id
)
SELECT DISTINCT employee_id
FROM RecursiveEmployeeCTE;
```

Explanation of the query:

1. The `RecursiveEmployeeCTE` is a recursive common table expression (CTE) that starts with employees who report directly to the head of the company (employee with `employee_id` 1).
2. The initial part of the CTE selects employees who report directly to the head (manager_id = 1).
3. The recursive part of the CTE selects employees who report to other employees found in the previous iteration.
4. The `UNION ALL` combines the initial and recursive parts of the CTE.
5. The final `SELECT DISTINCT` statement retrieves distinct `employee_id` values from the recursive CTE, representing all employees who directly or indirectly report their work to the head of the company.

This query should provide the desired output showing the `employee_id` values of all employees who report their work directly or indirectly to the head of the company. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q72.
Table: Transactions
Column Name Type
id int
country varchar
state enum
amount int
trans_date date
id is the primary key of this table.
The table has information about incoming transactions.
The state column is an enum of type ["approved", "declined"].
Write an SQL query to find for each month and country, the number of transactions and their total
amount, the number of approved transactions and their total amount.
Return the result table in any order.
The query result format is in the following example.
Input:
Transactions table:
id country state amount trans_date
121 US approved 1000 2018-12-18
122 US declined 2000 2018-12-19
123 US approved 2000 2019-01-01
124 DE approved 2000 2019-01-07
Output:
month country trans_count
approved_cou
nt
trans_total_a
mount roved_total_amo
2018-12 US 2 1 3000 1000
2019-01 US 1 1 2000 2000
2019-01 DE 1 1 2000 2000
ans-To find the number of transactions, total amount, number of approved transactions, and their total amount for each month and country, we can use the following SQL query:

```sql
SELECT
    DATE_FORMAT(trans_date, '%Y-%m') AS month,
    country,
    COUNT(*) AS trans_count,
    SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count,
    SUM(amount) AS trans_total_amount,
    SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount
FROM Transactions
GROUP BY month, country;
```

Explanation of the query:

1. The `DATE_FORMAT(trans_date, '%Y-%m')` function is used to extract the year and month from the `trans_date` column in the format 'YYYY-MM'.
2. The `COUNT(*)` function counts the total number of transactions for each month and country.
3. The `SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END)` counts the number of approved transactions for each month and country.
4. The `SUM(amount)` function calculates the total amount of transactions for each month and country.
5. The `SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END)` calculates the total amount of approved transactions for each month and country.
6. The `GROUP BY` clause groups the results by month and country.

This query should provide the desired output showing the number of transactions, total amount, number of approved transactions, and their total amount for each month and country. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q73.
Table: Actions
Column Name Type
user_id int
post_id int
action_date date
action enum
extra varchar
There is no primary key for this table, it may have duplicate rows.
The action column is an ENUM type of ('view', 'like', 'reaction', 'comment', 'report', 'share').
The extra column has optional information about the action, such as a reason for the report or a type
of reaction.
Table: Removals
Column Name Type
post_id int
remove_date date
post_id is the primary key of this table.
Each row in this table indicates that some post was removed due to being reported or as a result of an
admin review.
Write an SQL query to find the average daily percentage of posts that got removed after being
reported as spam, rounded to 2 decimal places.
The query result format is in the following example.
Input:
Actions table:
user_id post_id action_date action extra
1 1 2019-07-01 view null
1 1 2019-07-01 like null
1 1 2019-07-01 share null
2 2 2019-07-04 view null
2 2 2019-07-04 report spam
3 4 2019-07-04 view null
3 4 2019-07-04 report spam
4 3 2019-07-02 view null
4 3 2019-07-02 report spam
5 2 2019-07-03 view null
5 2 2019-07-03 report racism
5 5 2019-07-03 view null
5 5 2019-07-03 report racism
Removals table:
post_id remove_date
2 2019-07-20
3 2019-07-18
Output:
average_daily_percent
75
Explanation:
The percentage for 2019-07-04 is 50% because only one post of two spam reported posts were
removed.
The percentage for 2019-07-02 is 100% because one post was reported as spam and it was removed.
The other days had no spam reports so the average is (50 + 100) / 2 = 75%
Note that the output is only one number and that we do not care about the remove dates.
ans-To find the average daily percentage of posts that got removed after being reported as spam, we can use the following SQL query:

```sql
SELECT
    ROUND(AVG(removed_spam_percentage) * 100, 0) AS average_daily_percent
FROM (
    SELECT
        a.action_date,
        IFNULL(SUM(r.post_id IS NOT NULL AND a.action = 'report') / COUNT(DISTINCT a.post_id), 0) AS removed_spam_percentage
    FROM Actions a
    LEFT JOIN Removals r ON a.post_id = r.post_id
    GROUP BY a.action_date
) AS percentages;
```

Explanation of the query:

1. The inner subquery calculates the percentage of posts reported as spam that were removed for each day.
2. It uses a `LEFT JOIN` between the `Actions` and `Removals` tables on the `post_id`.
3. The `SUM(r.post_id IS NOT NULL AND a.action = 'report')` counts the number of posts reported as spam that were also removed.
4. The `COUNT(DISTINCT a.post_id)` counts the total number of distinct posts reported as spam.
5. The outer query calculates the average of the calculated percentages for all days.
6. The result is multiplied by 100 to get the percentage value and rounded to 0 decimal places.

This query should provide the desired average daily percentage of posts that got removed after being reported as spam. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q74.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the fraction of players that logged in again on the day after the day they
first logged in, rounded to 2 decimal places. In other words, you need to count the number of players
that logged in for at least two consecutive days starting from their first login date, then divide that
number by the total number of players.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-03-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
fraction
0.33
Explanation:
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33
ans:

```sql
SELECT
    ROUND(
        SUM(CASE WHEN DATEDIFF(event_date, LAG(event_date) OVER(PARTITION BY player_id ORDER BY event_date)) = 1 THEN 1 ELSE 0 END)
        / COUNT(DISTINCT player_id),
        2
    ) AS fraction
FROM Activity;
```

This query calculates the fraction of players who logged in again on the day after the day they first logged in. It checks for consecutive login days using the `LAG` window function and then divides the count of such players by the total number of distinct players. The result is rounded to 2 decimal places.
Q75.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the fraction of players that logged in again on the day after the day they
first logged in, rounded to 2 decimal places. In other words, you need to count the number of players
that logged in for at least two consecutive days starting from their first login date, then divide that
number by the total number of players.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-03-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
fraction
0.33
Explanation:
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33
ans-To calculate the fraction of players that logged in again on the day after the day they first logged in,we can use the following SQL query:

```sql
SELECT
    ROUND(
        SUM(CASE WHEN DATEDIFF(event_date, LAG(event_date) OVER(PARTITION BY player_id ORDER BY event_date)) = 1 THEN 1 ELSE 0 END)
        / COUNT(DISTINCT player_id),
        2
    ) AS fraction
FROM Activity;
```

Explanation of the query:

1. The query uses the `LAG` window function to get the previous event date for each player, ordered by event date.
2. The `CASE` statement checks if the difference in days between the current `event_date` and the previous `event_date` is exactly 1, which means the player logged in again on the day after the first login.
3. The `SUM` function adds up the counts of players who logged in on the day after the first login.
4. The `COUNT(DISTINCT player_id)` counts the total number of distinct players.
5. The result divides the sum of players who logged in again on the day after the first login by the total number of players and rounds the result to 2 decimal places.

This query should provide the desired fraction of players as shown in the sample output. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q76.
Table Salaries:
Column Name Type
company_id int
employee_id int
employee_name varchar
salary int
(company_id, employee_id) is the primary key for this table.
This table contains the company id, the id, the name, and the salary for an employee.
Write an SQL query to find the salaries of the employees after applying taxes. Round the salary to the
nearest integer.
The tax rate is calculated for each company based on the following criteria:
● 0% If the max salary of any employee in the company is less than $1000.
● 24% If the max salary of any employee in the company is in the range [1000, 10000] inclusive.
● 49% If the max salary of any employee in the company is greater than $10000.
Return the result table in any order.
The query result format is in the following example.
Input:
Salaries table:
company_id employee_id
employee_nam
e salary
1 1 Tony 2000
1 2 Pronub 21300
1 3 Tyrrox 10800
2 1 Pam 300
2 7 Bassem 450
2 9 Hermione 700
3 7 Bocaben 100
3 2 Ognjen 2200
3 13 Nyan Cat 3300
3 15 Morning Cat 7777
Output:
company_id employee_id employee_name salary
1 1 Tony 1020
1 2 Pronub 10863
1 3 Tyrrox 5508
2 1 Pam 300
2 7 Bassem 450
2 9 Hermione 700
3 7 Bocaben 76
3 2 Ognjen 1672
3 13 Nyan Cat 2508
3 15 Morning Cat 5911
Explanation:
For company 1, Max salary is 21300. Employees in company 1 have taxes = 49%
For company 2, Max salary is 700. Employees in company 2 have taxes = 0%
For company 3, Max salary is 7777. Employees in company 3 have taxes = 24%
The salary after taxes = salary - (taxes percentage / 100) * salary
For example, Salary for Morning Cat (3, 15) after taxes = 7777 - 7777 * (24 / 100) = 7777 - 1866.48 =
5910.52, which is rounded to 5911.
ans-To evaluate the boolean expressions in the `Expressions` table using the `Variables` table,we can use the following SQL query:

```sql
SELECT
    e.left_operand,
    e.operator,
    e.right_operand,
    CASE
        WHEN e.operator = '<' THEN v1.value < v2.value
        WHEN e.operator = '>' THEN v1.value > v2.value
        WHEN e.operator = '=' THEN v1.value = v2.value
    END AS value
FROM
    Expressions e
JOIN
    Variables v1 ON e.left_operand = v1.name
JOIN
    Variables v2 ON e.right_operand = v2.name;
```

Explanation of the query:

1. The query joins the `Expressions` table with the `Variables` table twice, once for each operand in the expression (`left_operand` and `right_operand`).
2. It calculates the value of each boolean expression using a `CASE` statement based on the operator. For each row, the result will be `true` or `false` depending on whether the expression is true or false.
3. The result includes the `left_operand`, `operator`, `right_operand`, and the calculated `value` for each boolean expression.

This query should provide the evaluated boolean expressions for each row in the `Expressions` table. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q77.
Table Variables:
Column Name Type
name varchar
value int
name is the primary key for this table.
This table contains the stored variables and their values.
Table Expressions:
Column Name Type
left_operand varchar
operator enum
right_operand varchar
(left_operand, operator, right_operand) is the primary key for this table.
This table contains a boolean expression that should be evaluated.
operator is an enum that takes one of the values ('<', '>', '=')
The values of left_operand and right_operand are guaranteed to be in the Variables table.
Write an SQL query to evaluate the boolean expressions in Expressions table.
Return the result table in any order.
The query result format is in the following example.
Input:
Variables table:
name value
x 66
y 77
Expressions table:
left_operand operator right_operand
x > y
x < y
x = y
y > x
y < x
x = x
Output:
left_operand operator right_operand value
x > y false
x < y true
x = y false
y > x true
y < x false
x = x true
Explanation:
As shown, you need to find the value of each boolean expression in the table using the variables table.
ans-To evaluate the boolean expressions in the `Expressions` table using the `Variables` table,we can use the following SQL query:

```sql
SELECT
    e.left_operand,
    e.operator,
    e.right_operand,
    CASE
        WHEN e.operator = '<' THEN v1.value < v2.value
        WHEN e.operator = '>' THEN v1.value > v2.value
        WHEN e.operator = '=' THEN v1.value = v2.value
    END AS value
FROM
    Expressions e
JOIN
    Variables v1 ON e.left_operand = v1.name
JOIN
    Variables v2 ON e.right_operand = v2.name;
```

Explanation of the query:

1. The query joins the `Expressions` table with the `Variables` table twice, once for each operand in the expression (`left_operand` and `right_operand`).
2. It calculates the value of each boolean expression using a `CASE` statement based on the operator. For each row, the result will be `true` or `false` depending on whether the expression is true or false.
3. The result includes the `left_operand`, `operator`, `right_operand`, and the calculated `value` for each boolean expression.

This query should provide the evaluated boolean expressions for each row in the `Expressions` table. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q78.
Table Person:
Column Name Type
id int
name varchar
phone_number varchar
id is the primary key for this table.
Each row of this table contains the name of a person and their phone number.
Phone number will be in the form 'xxx-yyyyyyy' where xxx is the country code (3 characters) and
yyyyyyy is the phone number (7 characters) where x and y are digits. Both can contain leading zeros.
Table Country:
Column Name Type
name varchar
country_code varchar
country_code is the primary key for this table.
Each row of this table contains the country name and its code. country_code will be in the form 'xxx'
where x is digits.
Table Calls:
Column Name Type
caller_id int
callee_id int
duration int
There is no primary key for this table, it may contain duplicates.
Each row of this table contains the caller id, callee id and the duration of the call in minutes. caller_id
!= callee_id
A telecommunications company wants to invest in new countries. The company intends to invest in
the countries where the average call duration of the calls in this country is strictly greater than the
global average call duration.
Write an SQL query to find the countries where this company can invest.
Return the result table in any order.
The query result format is in the following example.
Input:
Person table:
id name phone_number
3 Jonathan 051-1234567
12 Elvis 051-7654321
1 Moncef 212-1234567
2 Maroua 212-6523651
7 Meir 972-1234567
9 Rachel 972-0011100
Country table:
name country_code
Peru 51
Israel 972
Morocco 212
Germany 49
Ethiopia 251
Calls table:
caller_id callee_id duration
1 9 33
2 9 4
1 2 59
3 12 102
3 12 330
12 3 5
7 9 13
7 1 3
9 7 1
1 7 7
Output:
country
Peru
Explanation:
The average call duration for Peru is (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667
The average call duration for Israel is (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500
The average call duration for Morocco is (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000
Global call duration average = (2 * (33 + 4 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000
Since Peru is the only country where the average call duration is greater than the global average, it is
the only recommended country.
ans-To find the countries where the telecommunications company can invest,we need to calculate the average call duration for each country and compare it with the global average call duration. Here's the SQL query to achieve that:

```sql
SELECT c.name AS country
FROM Country c
JOIN Person p ON c.country_code = SUBSTRING(p.phone_number, 1, 3)
JOIN Calls ca ON p.id = ca.caller_id OR p.id = ca.callee_id
GROUP BY c.name
HAVING AVG(ca.duration) > (
    SELECT AVG(duration) * 2
    FROM Calls
);
```

Explanation of the query:

1. The query joins the `Country`, `Person`, and `Calls` tables based on their relationships and matches the country code from the phone number.
2. It calculates the average call duration for each country using the `AVG` function and groups the results by country name.
3. The `HAVING` clause filters the countries where the average call duration is greater than twice the global average call duration.
4. The result includes the names of countries where the company can invest.

This query should provide the list of countries where the telecommunications company can invest based on the given conditions. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q79.
Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in
alphabetical order.
Level - Easy
Hint - Use ORDER BY
Input Format
The Employee table containing employee data for a company is described as follows:
where employee_id is an employee's ID number, name is their name, months is the total number of
months they've been working for the company, and salary is their monthly salary.
Sample Input
Sample Output
Angela
Bonnie
Frank
Joe
Kimberly
Lisa
Michael
Patrick
Rose
Todd
ans-To print a list of employee names from the `Employee` table in alphabetical order,we can use the following SQL query with the `ORDER BY` clause:

```sql
SELECT name
FROM Employee
ORDER BY name;
```

Explanation: The query simply selects the `name` column from the `Employee` table and orders the results in alphabetical order using the `ORDER BY` clause.

This query will provide the list of employee names in alphabetical order as shown in the sample output.
Q80.
Assume you are given the table below containing information on user transactions for particular
products. Write a query to obtain the year-on-year growth rate for the total spend of each product for
each year.
Output the year (in ascending order) partitioned by product id, current year's spend, previous year's
spend and year-on-year growth rate (percentage rounded to 2 decimal places).
Level - Hard
Hint - Use extract function
user_transactions Table:
Column Name Type
transaction_id integer
product_id integer
spend decimal
transaction_date datetime
user_transactions Example Input:
transaction_i
d
product_i
d
spend transaction_date
1341 123424 1500.60 12/31/2019 12:00:00
1423 123424 1000.20 12/31/2020 12:00:00
1623 123424 1246.44 12/31/2021 12:00:00
1322 123424 2145.32 12/31/2022 12:00:00
Example Output:
y
e
a
r
product_i
d
curr_year_spend prev_year_spend yoy_rate
2
0
9
123424 1500.60
2
0
2
0
123424 1000.20 1500.60 -33.35
2
0
2
123424 1246.44 1000.20 24.62
2
0
2
2
123424 2145.32 1246.44 72.12
ans-To calculate the year-on-year growth rate for the total spend of each product for each year, we can use SQL queries with the `user_transactions` table and the `extract` function to extract year information from the `transaction_date` column. Here's the query we can use:

```sql
WITH SpendData AS (
    SELECT
        product_id,
        EXTRACT(YEAR FROM transaction_date) AS transaction_year,
        SUM(spend) AS total_spend
    FROM
        user_transactions
    GROUP BY
        product_id, transaction_year
),
LaggedData AS (
    SELECT
        product_id,
        transaction_year,
        LAG(total_spend) OVER (PARTITION BY product_id ORDER BY transaction_year) AS prev_year_spend,
        total_spend AS curr_year_spend
    FROM
        SpendData
)
SELECT
    LaggedData.transaction_year AS year,
    LaggedData.product_id,
    LaggedData.curr_year_spend,
    LaggedData.prev_year_spend,
    ROUND(
        (LaggedData.curr_year_spend - LaggedData.prev_year_spend) / LaggedData.prev_year_spend * 100,
        2
    ) AS yoy_rate
FROM
    LaggedData
ORDER BY
    LaggedData.product_id, LaggedData.transaction_year;
```

Explanation of the query:

1. The `SpendData` CTE calculates the total spend for each product in each year by using the `SUM` function and the `EXTRACT` function to extract the year from the `transaction_date` column.
2. The `LaggedData` CTE uses the `LAG` window function to get the previous year's spend for each product and year combination.
3. The main query calculates the year-on-year growth rate by subtracting the previous year's spend from the current year's spend and then dividing by the previous year's spend. The result is multiplied by 100 to get the percentage growth, rounded to 2 decimal places.
4. The final result includes the year, product ID, current year's spend, previous year's spend, and the year-on-year growth rate.

This query should give you the desired output with the year-on-year growth rate for the total spend of each product for each year. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q81.
Amazon wants to maximise the number of items it can stock in a 500,000 square feet warehouse. It
wants to stock as many prime items as possible, and afterwards use the remaining square footage to
stock the most number of non-prime items.
Write a SQL query to find the number of prime and non-prime items that can be stored in the 500,000
square feet warehouse. Output the item type and number of items to be stocked.
Hint - create a table containing a summary of the necessary fields such as item type ('prime_eligible',
'not_prime'), SUM of square footage, and COUNT of items grouped by the item type.
inventory table:
Column Name Type
item_id integer
item_type string
item_category string
square_footage decimal
inventory Example Input:
item_id item_type item_category square_footage
1374 prime_eligible mini refrigerator 68.00
4245 not_prime standing lamp 26.40
2452 prime_eligible television 85.00
3255 not_prime side table 22.60
1672 prime_eligible laptop 8.50
Example Output:
item_type item_count
prime_eligible 9285
not_prime 6
ans-To find the number of prime and non-prime items that can be stored in the 500,000 square feet warehouse, we can use the SQL query below:

```sql
SELECT
    item_type,
    COUNT(*) AS item_count
FROM (
    SELECT
        item_type,
        SUM(square_footage) AS total_square_footage
    FROM
        inventory
    GROUP BY
        item_type
) AS summarized_data
WHERE
    total_square_footage <= 500000
GROUP BY
    item_type;
```

Explanation of the query:

1. The inner query calculates the total square footage for each item type by using the `SUM` function and grouping by the `item_type` column.
2. The outer query filters the summarized data to only include rows where the `total_square_footage` is less than or equal to 500,000 square feet.
3. The `GROUP BY` clause groups the results by the `item_type` column.
4. The `COUNT(*)` function counts the number of rows for each item type.
5. The result provides the item type and the corresponding number of items that can be stocked in the warehouse within the space constraint.

This query should give you the output with the item type and the number of items that can be stored in the warehouse. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q82.
Assume you have the table below containing information on Facebook user actions. Write a query to
obtain the active user retention in July 2022. Output the month (in numerical format 1, 2, 3) and the
number of monthly active users (MAUs).
Hint: An active user is a user who has user action ("sign-in", "like", or "comment") in the current month
and last month.
Hint- Use generic correlated subquery
user_actions Table:
Column Name Type
user_id integer
event_id integer
event_type string ("sign-in, "like", "comment")
event_date datetime
user_actionsExample Input:
user_id event_id event_type event_date
445 7765 sign-in 05/31/2022 12:00:00
742 6458 sign-in 06/03/2022 12:00:00
445 3634 like 06/05/2022 12:00:00
742 1374 comment 06/05/2022 12:00:00
648 3124 like 06/18/2022 12:00:00
Example Output for June 2022:
month monthly_active_users
6 1
ans-To calculate the active user retention in July 2022, we can use SQL queries with correlated subqueries to match users who had events in both July 2022 and June 2022. Here's the query we can use:

```sql
SELECT
    7 AS month,
    COUNT(DISTINCT ua_july.user_id) AS monthly_active_users
FROM
    (SELECT DISTINCT user_id FROM user_actions WHERE MONTH(event_date) = 7 AND YEAR(event_date) = 2022) AS ua_july
    JOIN (SELECT DISTINCT user_id FROM user_actions WHERE MONTH(event_date) = 6 AND YEAR(event_date) = 2022) AS ua_june
    ON ua_july.user_id = ua_june.user_id;
```

Explanation of the query:

1. The subquery `(SELECT DISTINCT user_id FROM user_actions WHERE MONTH(event_date) = 7 AND YEAR(event_date) = 2022)` retrieves distinct user IDs who had events in July 2022.
2. The subquery `(SELECT DISTINCT user_id FROM user_actions WHERE MONTH(event_date) = 6 AND YEAR(event_date) = 2022)` retrieves distinct user IDs who had events in June 2022.
3. The `JOIN` operation matches user IDs between July and June user lists to determine active user retention.
4. The `COUNT(DISTINCT ua_july.user_id)` counts the number of users who had events in both July and June.
5. The result provides the count of users who were active in both July and June

Q83.
Google's marketing team is making a Superbowl commercial and needs a simple statistic to put on
their TV ad: the median number of searches a person made last year.
However, at Google scale, querying the 2 trillion searches is too costly. Luckily, you have access to the
summary table which tells you the number of searches made last year and how many Google users
fall into that bucket.
Write a query to report the median of searches made by a user. Round the median to one decimal
point.
Hint- Write a subquery or common table expression (CTE) to generate a series of data (that's keyword
for column) starting at the first search and ending at some point with an optional incremental value.
search_frequency Table:
Column Name Type
searches integer
num_users integer
search_frequency Example Input:
searches num_users
1 2
2 2
3 3
4 1
Example Output:
median
2.5
ans-To calculate the median number of searches made by a user, we can use SQL queries to calculate the cumulative sum of users and then find the median point. Here's the query we can use:

```sql
SELECT
    ROUND(
        CASE
            WHEN COUNT(*) % 2 = 0 THEN
                AVG(searches)
            ELSE
                MAX(searches)
        END,
        1
    ) AS median
FROM (
    SELECT
        s1.searches,
        SUM(s2.num_users) AS cumulative_users
    FROM
        search_frequency s1
        JOIN search_frequency s2 ON s1.searches >= s2.searches
    GROUP BY
        s1.searches
) AS cumulative_data
WHERE
    cumulative_users >= (SELECT SUM(num_users) FROM search_frequency) / 2;
```

Explanation of the query:

1. The subquery within the main query calculates the cumulative sum of users for each search frequency.
2. The main query then calculates the median by identifying the point where the cumulative users cross half of the total users.
3. If the total count of users is even, the median is the average of the two middle points.
4. If the total count of users is odd, the median is the value at the middle point.
This query provides the median number of searches made by a user, rounded to one decimal point. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q84.
Write a query to update the Facebook advertiser's status using the daily_pay table. Advertiser is a
two-column table containing the user id and their payment status based on the last payment and
daily_pay table has current information about their payment. Only advertisers who paid will show up in
this table.
Output the user id and current payment status sorted by the user id.
Hint- Query the daily_pay table and check through the advertisers in this table. .
advertiser Table:
Column Name Type
user_id string
status string
advertiser Example Input:
user_id status
bing NEW
yahoo NEW
alibaba EXISTING
daily_pay Table:
Column Name Type
user_id string
paid decimal
daily_pay Example Input:
user_id paid
yahoo 45.00
alibaba 100.00
target 13.00
Definition of advertiser status:
● New: users registered and made their first payment.
● Existing: users who paid previously and recently made a current payment.
● Churn: users who paid previously, but have yet to make any recent payment.
● Resurrect: users who did not pay recently but may have made a previous payment and have
made payment again recently.
Example Output:
user_id new_status
bing CHURN
yahoo EXISTING
alibaba EXISTING
Bing's updated status is CHURN because no payment was made in the daily_pay table whereas Yahoo
which made a payment is updated as EXISTING.
The dataset you are querying against may have different input & output - this is just an example!
Read this before proceeding to solve the question
For better understanding of the advertiser's status, we're sharing with you a table of possible
transitions based on the payment status.
# Start End Condition
1 NEW EXISTING Paid on day T
2 NEW CHURN No pay on day T
3 EXISTING EXISTING Paid on day T
4 EXISTING CHURN No pay on day T
5 CHURN RESURRECT Paid on day T
6 CHURN CHURN No pay on day T
7 RESURRECT EXISTING Paid on day T
8 RESURRECT CHURN No pay on day T
1. Row 2, 4, 6, 8: As long as the user has not paid on day T, the end status is updated to CHURN
regardless of the previous status.
2. Row 1, 3, 5, 7: When the user paid on day T, the end status is updated to either EXISTING or
RESURRECT, depending on their previous state. RESURRECT is only possible when the
previous state is CHURN. When the previous state is anything else, the status is updated to
EXISTING.
ans-To update the advertiser's status based on the daily payment information, we can use a combination of SQL queries to identify the advertiser's status transitions according to the provided rules. Here's the query we can use:

```sql
UPDATE advertiser AS a
SET status =
    CASE
        WHEN d.paid IS NULL AND a.status IN ('NEW', 'EXISTING', 'RESURRECT') THEN 'CHURN'
        WHEN d.paid IS NOT NULL AND a.status IN ('NEW', 'EXISTING', 'CHURN') THEN 'EXISTING'
        WHEN d.paid IS NOT NULL AND a.status = 'RESURRECT' THEN 'EXISTING'
        ELSE a.status
    END
FROM daily_pay AS d
WHERE a.user_id = d.user_id;

SELECT user_id, status AS new_status FROM advertiser ORDER BY user_id;
```

Explanation of the query:

1. The `UPDATE` statement updates the `status` column of the `advertiser` table based on the rules provided. The `CASE` statement handles the logic for updating the status based on the transitions specified in the hint.
2. For each row in the `advertiser` table, the query checks the conditions and updates the status column accordingly.
3. The `FROM daily_pay AS d` part of the query allows you to join the `daily_pay` table to obtain the payment information for each advertiser.
4. The `WHERE a.user_id = d.user_id` condition ensures that only advertisers with payment information are considered for the update.
5. The `SELECT` statement retrieves the updated user IDs and their corresponding statuses.
6. The result is sorted by user ID.

This query should update the advertiser's status based on the daily payment information and provide you with the desired output. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q85.
Amazon Web Services (AWS) is powered by fleets of servers. Senior management has requested
data-driven solutions to optimise server usage.
Write a query that calculates the total time that the fleet of servers was running. The output should be
in units of full days.
Level - Hard
Hint1. Calculate individual uptimes
2. Sum those up to obtain the uptime of the whole fleet, keeping in mind that the result must be
output in units of full days
Assumptions:
● Each server might start and stop several times.
● The total time in which the server fleet is running can be calculated as the sum of each
server's uptime.
server_utilization Table:
Column Name Type
server_id integer
status_time timestamp
session_status string
server_utilization Example Input:
server_id status_time session_status
1 08/02/2022 10:00:00 start
1 08/04/2022 10:00:00 stop
2 08/17/2022 10:00:00 start
2 08/24/2022 10:00:00 stop
Example Output:
total_uptime_days
21
ans-To calculate the total time that the fleet of servers was running in full days, we'll need to calculate the individual uptimes for each server and then sum those uptimes to obtain the uptime of the whole fleet in days. Here's the query we can use:

```sql
SELECT
    FLOOR(SUM(UNIX_TIMESTAMP(stop_time) - UNIX_TIMESTAMP(start_time)) / (60 * 60 * 24)) AS total_uptime_days
FROM (
    SELECT
        server_id,
        MIN(status_time) AS start_time,
        MAX(status_time) AS stop_time
    FROM
        server_utilization
    GROUP BY
        server_id, DATE(status_time)
    HAVING
        MIN(session_status) = 'start' AND MAX(session_status) = 'stop'
) AS server_uptimes;
```

Explanation of the query:

1. The inner query groups the server utilization records by `server_id` and the date part of the `status_time` (ignoring the time of day).
2. Within each group, it selects the minimum `status_time` as the server's start time and the maximum `status_time` as the server's stop time.
3. It filters out groups where the minimum status is not 'start' or the maximum status is not 'stop' to ensure complete server uptime records.
4. The outer query calculates the difference in seconds between the stop time and start time for each server's uptime using the `UNIX_TIMESTAMP` function.
5. The `FLOOR` function then converts the total uptime time in seconds to full days.
6. The result is the total uptime of the server fleet in full days.

This query assumes that the `server_utilization` table contains records for server start and stop times, with each server's sessions properly paired (i.e., a 'start' session followed by a 'stop' session). Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q86.
Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure or
a retry error that causes a credit card to be charged twice.
Using the transactions table, identify any payments made at the same merchant with the same credit
card for the same amount within 10 minutes of each other. Count such repeated payments.
Level - Hard
Hint- Use Partition and order by
Assumptions:
● The first transaction of such payments should not be counted as a repeated payment. This
means, if there are two transactions performed by a merchant with the same credit card and
for the same amount within 10 minutes, there will only be 1 repeated payment.
transactions Table:
Column Name Type
transaction_id integer
merchant_id integer
credit_card_id integer
amount integer
transaction_timestamp datetime
transactions Example Input:
transaction_id merchant_id credit_card_id amount transaction_timestamp
1 101 1 100 09/25/2022 12:00:00
2 101 1 100 09/25/2022 12:08:00
3 101 1 100 09/25/2022 12:28:00
4 102 2 300 09/25/2022 12:00:00
6 102 2 400 09/25/2022 14:00:00
Example Output:
payment_count
1
ans-To identify repeated payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other,we can use SQL queries with the `transactions` table. Here's the query we can use:

```sql
WITH RankedTransactions AS (
    SELECT
        transaction_id,
        merchant_id,
        credit_card_id,
        amount,
        transaction_timestamp,
        LAG(transaction_timestamp) OVER (PARTITION BY merchant_id, credit_card_id, amount ORDER BY transaction_timestamp) AS prev_transaction_timestamp
    FROM
        transactions
)
SELECT
    COUNT(DISTINCT CASE WHEN TIME_TO_SEC(TIMEDIFF(transaction_timestamp, prev_transaction_timestamp)) <= 600 THEN transaction_id ELSE NULL END) AS payment_count
FROM
    RankedTransactions
WHERE
    prev_transaction_timestamp IS NOT NULL;
```

Explanation of the query:

1. We use a common table expression (CTE) named `RankedTransactions` to calculate the difference between consecutive transactions using the `LAG` window function.
2. The `LAG` function helps us retrieve the previous transaction timestamp within the same group (merchant, credit card, and amount) ordered by the transaction timestamp.
3. We then select transactions where the time difference between the current transaction and the previous transaction is within 10 minutes (600 seconds).
4. The `CASE` statement in the main query counts distinct transaction IDs for those transactions that satisfy the time difference condition. We count distinct IDs to ensure that if there are multiple repeated transactions, they are counted only once.
5. The result is the count of repeated payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other.

This query uses window functions and a common table expression to efficiently identify and count the repeated payments while excluding the first transaction in each repeated set. Make sure to adapt the query as needed to match the syntax and features of your specific SQL database system.
Q87.
DoorDash's Growth Team is trying to make sure new users (those who are making orders in their first
14 days) have a great experience on all their orders in their 2 weeks on the platform.
Unfortunately, many deliveries are being messed up because:
● the orders are being completed incorrectly (missing items, wrong order, etc.)
● the orders aren't being received (wrong address, wrong drop off spot)
● the orders are being delivered late (the actual delivery time is 30 minutes later than when the
order was placed). Note that the estimated_delivery_timestamp is automatically set to 30
minutes after the order_timestamp.
Hint- Use Where Clause and joins
Write a query to find the bad experience rate in the first 14 days for new users who signed up in June
2022. Output the percentage of bad experience rounded to 2 decimal places.
orders Table:
Column Name Type
order_id integer
customer_id integer
trip_id integer
status string ('completed successfully', 'completed incorrectly', 'never
received')
order_timestamp timestamp
orders Example Input:
order_id customer_id trip_id status order_timestamp
727424 8472 100463 completed
successfully
06/05/2022 09:12:00
242513 2341 100482 completed
incorrectly
06/05/2022 14:40:00
141367 1314 100362 completed
incorrectly
06/07/2022 15:03:00
582193 5421 100657 never_received 07/07/2022 15:22:00
253613 1314 100213 completed
successfully
06/12/2022 13:43:00
trips Table:
Column Name Type
dasher_id integer
trip_id integer
estimated_delivery_timestamp timestamp
actual_delivery_timestamp timestamp
trips Example Input:
dasher_id trip_id estimated_delivery_timestamp actual_delivery_timestamp
101 100463 06/05/2022 09:42:00 06/05/2022 09:38:00
102 100482 06/05/2022 15:10:00 06/05/2022 15:46:00
101 100362 06/07/2022 15:33:00 06/07/2022 16:45:00
102 100657 07/07/2022 15:52:00 -
103 100213 06/12/2022 14:13:00 06/12/2022 14:10:00
customers Table:
Column Name Type
customer_id integer
signup_timestamp timestamp
customers Example Input:
customer_id signup_timestamp
8472 05/30/2022 00:00:00
2341 06/01/2022 00:00:00
1314 06/03/2022 00:00:00
1435 06/05/2022 00:00:00
5421 06/07/2022 00:00:00
Example Output:
bad_experience_pct
75.00
ans-To calculate the bad experience rate for new users who signed up in June 2022,we can use SQL queries with the given tables and conditions. Here's the query we can use:

```sql
SELECT
    ROUND(
        (COUNT(CASE WHEN o.status IN ('completed incorrectly', 'never received')
                    THEN 1 ELSE NULL END) / COUNT(*)) * 100,
        2
    ) AS bad_experience_pct
FROM
    customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN trips t ON o.trip_id = t.trip_id
WHERE
    c.signup_timestamp >= '2022-06-01' AND c.signup_timestamp < '2022-07-01'
    AND o.order_timestamp >= c.signup_timestamp
    AND o.order_timestamp < DATEADD(day, 14, c.signup_timestamp)
    AND (
        t.actual_delivery_timestamp IS NULL
        OR t.actual_delivery_timestamp > DATEADD(minute, 30, o.order_timestamp)
    );
```

Please note that this query assumes that your SQL database system supports the `DATEADD` function to manipulate dates and times. Also, replace `'2022-06-01'` and `'2022-07-01'` with appropriate date format based on your database system if needed.

Explanation of the query:

1. We join the `customers`, `orders`, and `trips` tables based on their corresponding IDs.
2. We filter for customers who signed up in June 2022 (`signup_timestamp >= '2022-06-01' AND signup_timestamp < '2022-07-01'`).
3. We filter for orders made within 14 days after the customer's signup (`o.order_timestamp >= c.signup_timestamp AND o.order_timestamp < DATEADD(day, 14, c.signup_timestamp)`).
4. We use a `CASE` statement to count orders with bad experiences ('completed incorrectly' or 'never received').
5. We calculate the bad experience rate as a percentage by dividing the count of bad experience orders by the total count of orders made by these new users within the specified period.
6. The result is rounded to 2 decimal places using the `ROUND` function.

Please adapt the query as needed to match the syntax and features of your specific SQL database system.
Q88
Table: Scores
Column Name Type
player_name varchar
gender varchar
day date
score_points int
(gender, day) is the primary key for this table.
A competition is held between the female team and the male team.
Each row of this table indicates that a player_name and with gender has scored score_point in
someday.
Gender is 'F' if the player is in the female team and 'M' if the player is in the male team.
Write an SQL query to find the total score for each gender on each day.
Return the result table ordered by gender and day in ascending order.
The query result format is in the following example.
Input:
Scores table:
player_name gender day score_points
Aron F 2020-01-01 17
Alice F 2020-01-07 23
Bajrang M 2020-01-07 7
Khali M 2019-12-25 11
Slaman M 2019-12-30 13
Joe M 2019-12-31 3
Jose M 2019-12-18 2
Priya F 2019-12-31 23
Priyanka F 2019-12-30 17
Output:
gender day total
F 2019-12-30 17
F 2019-12-31 40
F 2020-01-01 57
F 2020-01-07 80
M 2019-12-18 2
M 2019-12-25 13
M 2019-12-30 26
M 2019-12-31 29
M 2020-01-07 36
Explanation:
For the female team:
The first day is 2019-12-30, Priyanka scored 17 points and the total score for the team is 17.
The second day is 2019-12-31, Priya scored 23 points and the total score for the team is 40.
The third day is 2020-01-01, Aron scored 17 points and the total score for the team is 57.
The fourth day is 2020-01-07, Alice scored 23 points and the total score for the team is 80.
For the male team:
The first day is 2019-12-18, Jose scored 2 points and the total score for the team is 2.
The second day is 2019-12-25, Khali scored 11 points and the total score for the team is 13.
The third day is 2019-12-30, Slaman scored 13 points and the total score for the team is 26.
The fourth day is 2019-12-31, Joe scored 3 points and the total score for the team is 29.
The fifth day is 2020-01-07, Bajrang scored 7 points and the total score for the team is 36.
ans-To find the total score for each gender on each day,we can use the following SQL query:

```sql
SELECT 
    gender, 
    day, 
    SUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total
FROM Scores
ORDER BY gender, day;
```

This query uses the `SUM` window function with the `OVER` clause to calculate the cumulative total score for each gender ordered by day. The `PARTITION BY` clause ensures that the sum is calculated separately for each gender. The result is then ordered by gender and day.

The query returns the desired output, showing the total score for each gender on each day.
Q89.
Table Person:
Column Name Type
id int
name varchar
phone_number varchar
id is the primary key for this table.
Each row of this table contains the name of a person and their phone number.
Phone number will be in the form 'xxx-yyyyyyy' where xxx is the country code (3 characters) and
yyyyyyy is the phone number (7 characters) where x and y are digits. Both can contain leading zeros.
Table Country:
Column Name Type
name varchar
country_code varchar
country_code is the primary key for this table.
Each row of this table contains the country name and its code. country_code will be in the form 'xxx'
where x is digits.
Table Calls:
Column Name Type
caller_id int
callee_id int
duration int
There is no primary key for this table, it may contain duplicates.
Each row of this table contains the caller id, callee id and the duration of the call in minutes. caller_id
!= callee_id
A telecommunications company wants to invest in new countries. The company intends to invest in
the countries where the average call duration of the calls in this country is strictly greater than the
global average call duration.
Write an SQL query to find the countries where this company can invest.
Return the result table in any order.
The query result format is in the following example.
Input:
Person table:
id name phone_number
3 Jonathan 051-1234567
12 Elvis 051-7654321
1 Moncef 212-1234567
2 Maroua 212-6523651
7 Meir 972-1234567
9 Rachel 972-0011100
Country table:
name country_code
Peru 51
Israel 972
Morocco 212
Germany 49
Ethiopia 251
Ethiopia 251
Calls table:
caller_id callee_id duration
1 9 33
2 9 4
1 2 59
3 12 102
3 12 330
12 3 5
7 9 13
7 1 3
9 7 1
1 7 7
Output:
country
Peru
Explanation:
The average call duration for Peru is (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667
The average call duration for Israel is (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500
The average call duration for Morocco is (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000
Global call duration average = (2 * (33 + 4 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000
Since Peru is the only country where the average call duration is greater than the global average, it is
the only recommended country.
ans-To find the countries where the average call duration of the calls is strictly greater than the global average call duration,we can use the following SQL query:

```sql
SELECT c.name AS country
FROM Country c
JOIN Person p ON c.country_code = SUBSTRING(p.phone_number, 1, 3)
JOIN Calls ca ON p.id = ca.caller_id OR p.id = ca.callee_id
GROUP BY c.name
HAVING AVG(ca.duration) > (
    SELECT (2 * SUM(duration)) / COUNT(*) AS global_avg
    FROM Calls
);
```

This query joins the `Country` table with the `Person` and `Calls` tables to gather the necessary information. It calculates the average call duration for each country and compares it to the global average call duration.

The `JOIN` clauses link the tables based on country codes and caller/callee IDs.

The `GROUP BY` clause groups the results by country.

The `HAVING` clause filters out countries where the average call duration is not greater than the global average call duration.

The result is a list of recommended countries where the company can invest, based on the given conditions.
Q90.
Table: Numbers
Column Name Type
num int
frequency int
num is the primary key for this table.
Each row of this table shows the frequency of a number in the database.
The median is the value separating the higher half from the lower half of a data sample.
Write an SQL query to report the median of all the numbers in the database after decompressing the
Numbers table. Round the median to one decimal point.
The query result format is in the following example.
Input:
Numbers table:
num frequency
0 7
1 1
2 3
3 1
Output:
median
0
Explanation:
If we decompose the Numbers table, we will get [0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3], so the median is (0 + 0) /
2 = 0.
ans-To calculate the median of all the numbers in the database after decompressing the Numbers table,we can use the following SQL query:

```sql
SELECT 
    CASE
        WHEN COUNT(*) % 2 = 0 THEN (MAX(num1) + MIN(num2)) / 2.0
        ELSE MAX(num1)
    END AS median
FROM (
    SELECT 
        n1.num AS num1, 
        n2.num AS num2
    FROM Numbers n1
    JOIN Numbers n2
    ON n1.num >= n2.num
) median_nums;
```

This query first joins the Numbers table with itself (aliased as n1 and n2) to create pairs of numbers. The join condition `n1.num >= n2.num` ensures that each pair includes all possible combinations without duplication.

The outer query then calculates the median. If the count of pairs is even (`COUNT(*) % 2 = 0`), it calculates the average of the maximum and minimum numbers in the pair. If the count is odd, it simply selects the maximum number.

The result is the median of the decompressed Numbers table, rounded to one decimal point.
Q91.
Table: Salary
Column Name Type
id int
employee_id int
amount int
pay_date date
id is the primary key column for this table.
Each row of this table indicates the salary of an employee in one month.
employee_id is a foreign key from the Employee table.
Table: Employee
Column Name Type
employee_id int
department_id int
employee_id is the primary key column for this table.
Each row of this table indicates the department of an employee.
Write an SQL query to report the comparison result (higher/lower/same) of the average salary of
employees in a department to the company's average salary.
Return the result table in any order.
The query result format is in the following example.
Input:
Salary table:
id employee_id amount pay_date
1 1 9000 2017/03/31
2 2 6000 2017/03/31
3 3 10000 2017/03/31
4 1 7000 2017/02/28
5 2 6000 2017/02/28
6 3 8000 2017/02/28
Employee table:
employee_id department_id
1 1
2 2
3 2
Output:
pay_month department_id comparison
2017-02 1 same
2017-03 1 higher
2017-02 2 same
2017-03 2 lower
Explanation:
In March, the company's average salary is (9000+6000+10000)/3 = 8333.33...
The average salary for department '1' is 9000, which is the salary of employee_id '1' since there is only
one employee in this department. So the comparison result is 'higher' since 9000 > 8333.33 obviously.
The average salary of department '2' is (6000 + 10000)/2 = 8000, which is the average of employee_id
'2' and '3'. So the comparison result is 'lower' since 8000 < 8333.33.
With the same formula for the average salary comparison in February, the result is 'same' since both
the departments '1' and '2' have the same average salary with the company, which is 7000.
ans-To compare the average salary of employees in each department to the company's average salary, we can use the following SQL query:

```sql
SELECT
    DATE_FORMAT(s.pay_date, '%Y-%m') AS pay_month,
    e.department_id,
    CASE 
        WHEN AVG(s.amount) > c.company_avg_salary THEN 'higher'
        WHEN AVG(s.amount) < c.company_avg_salary THEN 'lower'
        ELSE 'same'
    END AS comparison
FROM Salary s
JOIN Employee e ON s.employee_id = e.employee_id
CROSS JOIN (
    SELECT AVG(amount) AS company_avg_salary
    FROM Salary
) c
GROUP BY pay_month, e.department_id;
```

This query calculates the average salary for each department in each pay month and compares it to the company's average salary.

It first calculates the company's average salary using a subquery in the `CROSS JOIN` clause.

Then, it joins the `Salary` table with the `Employee` table on the `employee_id` column. It uses the `DATE_FORMAT` function to extract the year and month from the `pay_date` column.

The `CASE` statement is used to determine whether the department's average salary is higher, lower, or the same as the company's average salary.

The result is grouped by `pay_month` and `department_id` and provides the comparison result ('higher', 'lower', or 'same').
Q92.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
The install date of a player is the first login day of that player.
We define day one retention of some date x to be the number of players whose install date is x and
they logged back in on the day right after x, divided by the number of players whose install date is x,
rounded to 2 decimal places.
Write an SQL query to report for each install date, the number of players that installed the game on
that day, and the day one retention.
Return the result table in any order.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-03-02 6
2 3 2017-06-25 1
3 1 2016-03-01 0
3 4 2016-07-03 5
Output:
install_dt installs Day1_retention
2016-03-01 2 0.5
2017-06-25 1 0
Explanation:
Player 1 and 3 installed the game on 2016-03-01 but only player 1 logged back in on 2016-03-02 so
the day 1 retention of 2016-03-01 is 1 / 2 = 0.50
Player 2 installed the game on 2017-06-25 but didn't log back in on 2017-06-26 so the day 1 retention
of 2017-06-25 is 0 / 1 = 0.00
ans-To calculate the day one retention for each install date, we can use the following SQL query:

```sql
SELECT 
    a.event_date AS install_dt,
    COUNT(DISTINCT a.player_id) AS installs,
    ROUND(
        IFNULL(COUNT(DISTINCT CASE WHEN DATE_ADD(a.event_date, INTERVAL 1 DAY) = a2.event_date THEN a.player_id END) / COUNT(DISTINCT a.player_id), 0),
        2
    ) AS Day1_retention
FROM Activity a
LEFT JOIN Activity a2 ON a.player_id = a2.player_id
WHERE a.event_date = (SELECT MIN(event_date) FROM Activity WHERE player_id = a.player_id)
GROUP BY a.event_date;
```

This query calculates the day one retention for each install date by performing a self-join on the `Activity` table and counting the players who logged back in on the day right after their install date. It uses the `DATE_ADD` function to add one day to the install date and compares it with the event date in the self-join.

The `IFNULL` function is used to handle cases where there are no logins on the day right after the install date.

The result is grouped by the install date and provides the number of installs and the day one retention rounded to two decimal places.
Q93.
Table: Players
Column Name Type
player_id int
group_id int
player_id is the primary key of this table.
Each row of this table indicates the group of each player.
Table: Matches
Column Name Type
match_id int
first_player int
second_player int
first_score int
second_score int
match_id is the primary key of this table.
Each row is a record of a match, first_player and second_player contain the player_id of each match.
first_score and second_score contain the number of points of the first_player and second_player
respectively.
You may assume that, in each match, players belong to the same group.
The winner in each group is the player who scored the maximum total points within the group. In the
case of a tie, the lowest player_id wins.
Write an SQL query to find the winner in each group.
Return the result table in any order.
The query result format is in the following example.
Input:
Players table:
player_id group_id
15 1
25 1
30 1
45 1
10 2
35 2
50 2
20 3
40 3
Matches table:
match_id first_player second_player first_score second_score
1 15 45 3 0
2 30 25 1 2
3 30 15 2 0
4 40 20 5 2
5 35 50 1 1
Output:
group_id player_id
1 15
2 35
3 40
ans-To find the winner in each group (player who scored the maximum total points within the group),we can use a combination of subqueries and aggregation. Here's the SQL query:

```sql
SELECT p.group_id, 
       CASE WHEN MAX(p.total_points) = MAX(m.first_score) THEN m.first_player
            WHEN MAX(p.total_points) = MAX(m.second_score) THEN m.second_player
       END AS player_id
FROM (
    SELECT p.player_id, 
           p.group_id, 
           COALESCE(SUM(m.first_score), 0) + COALESCE(SUM(m.second_score), 0) AS total_points
    FROM Players p
    LEFT JOIN Matches m ON p.player_id = m.first_player OR p.player_id = m.second_player
    GROUP BY p.player_id, p.group_id
) p
JOIN Matches m ON p.player_id = m.first_player OR p.player_id = m.second_player
GROUP BY p.group_id;
```

This query first calculates the total points scored by each player within their respective group using a subquery. The subquery performs a LEFT JOIN between the `Players` table and the `Matches` table to calculate the total points for each player. The COALESCE function is used to handle cases where a player might not have participated in any match.

Then, the main query joins the result of the subquery with the `Matches` table again to determine the winner within each group. The CASE statement checks if the maximum total points match either the `first_score` or the `second_score`, and returns the corresponding `player_id` as the winner.

The result is a list of winners in each group, and it is ordered by `group_id`.
Q94.
Table: Student
Column Name Type
student_id int
student_name varchar
student_id is the primary key for this table.
student_name is the name of the student.
Table: Exam
Column Name Type
exam_id int
student_id int
score int
(exam_id, student_id) is the primary key for this table.
Each row of this table indicates that the student with student_id had a score points in the exam with id
exam_id.
A quiet student is the one who took at least one exam and did not score the high or the low score.
Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not
return the student who has never taken any exam.
Return the result table ordered by student_id.
The query result format is in the following example.
Input:
Student table:
student_id student_name
1 Daniel
2 Jade
3 Stella
4 Jonathan
5 Will
Exam table:
exam_id student_id score
10 1 70
10 2 80
10 3 90
20 1 80
30 1 70
30 3 80
30 4 90
40 1 60
40 2 70
40 4 80
Output:
student_id student_name
2 Jade
Explanation:
For exam 1: Student 1 and 3 hold the lowest and high scores respectively.
For exam 2: Student 1 holds both the highest and lowest score.
For exam 3 and 4: Student 1 and 4 hold the lowest and high scores respectively.
Students 2 and 5 have never got the highest or lowest in any of the exams.
Since student 5 is not taking any exam, he is excluded from the result.
So, we only return the information of Student 2.
ans-To find the students who are quiet in all exams (students who took at least one exam and did not score the highest or the lowest), you can use subqueries and aggregation. Here's the SQL query:

```sql
SELECT s.student_id, s.student_name
FROM Student s
WHERE s.student_id IN (
    SELECT e.student_id
    FROM Exam e
    GROUP BY e.student_id
    HAVING MIN(e.score) > (SELECT MIN(score) FROM Exam) 
       AND MAX(e.score) < (SELECT MAX(score) FROM Exam)
);
```

This query first calculates the lowest and highest scores across all exams using subqueries `(SELECT MIN(score) FROM Exam)` and `(SELECT MAX(score) FROM Exam)`.

Then, it uses a subquery to group the students by `student_id` and filters out those who have the lowest or highest scores for any exam by checking if their minimum score (`MIN(score)`) is greater than the global minimum score and their maximum score (`MAX(score)`) is less than the global maximum score.

The result is a list of students who are quiet in all exams, excluding those who have never taken any exam, and it is ordered by `student_id`.
Q95.
Table: Student
Column Name Type
student_id int
student_name varchar
student_id is the primary key for this table.
student_name is the name of the student.
Table: Exam
Column Name Type
exam_id int
student_id int
score int
(exam_id, student_id) is the primary key for this table.
Each row of this table indicates that the student with student_id had a score points in the exam with id
exam_id.
A quiet student is the one who took at least one exam and did not score the high or the low score.
Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not
return the student who has never taken any exam.
Return the result table ordered by student_id.
The query result format is in the following example.
Input:
Student table:
student_id student_name
1 Daniel
2 Jade
3 Stella
4 Jonathan
5 Will
Exam table:
exam_id student_id score
10 1 70
10 2 80
10 3 90
20 1 80
30 1 70
30 3 80
30 4 90
40 1 60
40 2 70
40 4 80
Output:
student_id student_name
2 Jade
Explanation:
For exam 1: Student 1 and 3 hold the lowest and high scores respectively.
For exam 2: Student 1 holds both the highest and lowest score.
For exam 3 and 4: Student 1 and 4 hold the lowest and high scores respectively.
Students 2 and 5 have never got the highest or lowest in any of the exams.
Since student 5 is not taking any exam, he is excluded from the result.
So, we only return the information of Student 2.
ans-To find the students who are quiet in all exams (students who took at least one exam and did not score the highest or the lowest), you can use a combination of subqueries and aggregation. Here's the SQL query:

```sql
SELECT student_id, student_name
FROM Student
WHERE student_id IN (
    SELECT student_id
    FROM Exam
    GROUP BY student_id
    HAVING MIN(score) > (SELECT MIN(score) FROM Exam) 
       AND MAX(score) < (SELECT MAX(score) FROM Exam)
);
```

This query first calculates the lowest and highest scores across all exams using subqueries `(SELECT MIN(score) FROM Exam)` and `(SELECT MAX(score) FROM Exam)`.

Then, it uses a subquery to group the students by `student_id` and filters out those who have the lowest or highest scores for any exam by checking if their minimum score (`MIN(score)`) is greater than the global minimum score and their maximum score (`MAX(score)`) is less than the global maximum score.

The result is a list of students who are quiet in all exams, excluding those who have never taken any exam, and it is ordered by `student_id`.
Q96.
You're given two tables on Spotify users' streaming data. songs_history table contains the historical
streaming data and songs_weekly table contains the current week's streaming data.
Write a query to output the user id, song id, and cumulative count of song plays as of 4 August 2022
sorted in descending order.
Hint- Use group by
Definitions:
● song_weekly table currently holds data from 1 August 2022 to 7 August 2022.
● songs_history table currently holds data up to to 31 July 2022. The output should include the
historical data in this table.
Assumption:
● There may be a new user or song in the songs_weekly table not present in the songs_history
table.
songs_history Table:
Column Name Type
history_id integer
user_id integer
song_id integer
song_plays integer
songs_history Example Input:
history_id user_id song_id song_plays
10011 777 1238 11
12452 695 4520 1
song_plays: Refers to the historical count of streaming or song plays by the user.
songs_weekly Table:
Column Name Type
user_id integer
song_id integer
listen_time datetime
songs_weekly Example Input:
user_id song_id listen_time
777 1238 08/01/2022 12:00:00
695 4520 08/04/2022 08:00:00
125 9630 08/04/2022 16:00:00
695 9852 08/07/2022 12:00:00
Example Output:
user_id song_id song_plays
777 1238 12
695 4520 2
125 9630 1
ans-To calculate the cumulative count of song plays for each user and song combination as of 4 August 2022 (including historical data from the `songs_history` table and current week's data from the `songs_weekly` table), you can use a combination of UNION, GROUP BY, and SUM. Here's the SQL query:

```sql
SELECT user_id, song_id, SUM(song_plays) AS song_plays
FROM (
    SELECT user_id, song_id, song_plays
    FROM songs_history
    UNION ALL
    SELECT sw.user_id, sw.song_id, 1 AS song_plays
    FROM songs_weekly sw
    WHERE listen_time <= '2022-08-04 23:59:59'
) combined_data
GROUP BY user_id, song_id
ORDER BY song_plays DESC;
```

This query combines data from both the `songs_history` and `songs_weekly` tables using UNION ALL, effectively including historical data and data from the current week up to 4 August 2022. It then groups the combined data by `user_id` and `song_id`, and calculates the cumulative sum of `song_plays` for each group.

The result is sorted in descending order of `song_plays`.

Please note that the query assumes that the `listen_time` column in the `songs_weekly` table represents the timestamp when the song was played. Adjust the column name as necessary based on your actual table structure.
Q97.
New TikTok users sign up with their emails, so each signup requires a text confirmation to activate the
new user's account.
Write a query to find the confirmation rate of users who confirmed their signups with text messages.
Round the result to 2 decimal places.
Hint- Use Joins
Assumptions:
● A user may fail to confirm several times with text. Once the signup is confirmed for a user,
they will not be able to initiate the signup again.
● A user may not initiate the signup confirmation process at all.
emails Table:
Column Name Type
email_id integer
user_id integer
signup_date datetime
emails Example Input:
email_id user_id signup_date
125 7771 06/14/2022 00:00:00
236 6950 07/01/2022 00:00:00
433 1052 07/09/2022 00:00:00
texts Table:
Column Name Type
text_id integer
email_id integer
signup_action varchar
texts Example Input:
text_id email_id signup_action
6878 125 Confirmed
6920 236 Not Confirmed
6994 236 Confirmed
Example Output:
confirm_rate
0.67
ans-To calculate the confirmation rate of users who confirmed their signups with text messages, you can use a combination of joins and aggregation. Here's the SQL query:

```sql
SELECT
    ROUND(
        SUM(CASE WHEN t.signup_action = 'Confirmed' THEN 1 ELSE 0 END) /
        COUNT(DISTINCT e.user_id) * 1.0,
        2) AS confirm_rate
FROM texts t
JOIN emails e ON t.email_id = e.email_id;
```

This query joins the `texts` table with the `emails` table using the `email_id` column as the join condition. It then calculates the confirmation rate by counting the number of confirmed signups (`signup_action = 'Confirmed'`) and dividing it by the total number of distinct user IDs from the `emails` table.

The `ROUND` function is used to round the result to two decimal places. The multiplication by `1.0` is used to ensure that the division result is treated as a decimal, avoiding integer division.

The result is a single row with the confirmation rate.
Q98.
The table below contains information about tweets over a given period of time. Calculate the 3-day
rolling average of tweets published by each user for each date that a tweet was posted. Output the
user id, tweet date, and rolling averages rounded to 2 decimal places.
Hint- Use Count and group by
Important Assumptions:
● Rows in this table are consecutive and ordered by date.
● Each row represents a different day
● A day that does not correspond to a row in this table is not counted. The most recent day is
the next row above the current row.
Note: Rolling average is a metric that helps us analyze data points by creating a series of averages
based on different subsets of a dataset. It is also known as a moving average, running average,
moving mean, or rolling mean.
tweets Table:
Column Name Type
tweet_id integer
user_id integer
tweet_date timestamp
tweets Example Input:
tweet_id user_id tweet_date
214252 111 06/01/2022 12:00:00
739252 111 06/01/2022 12:00:00
846402 111 06/02/2022 12:00:00
241425 254 06/02/2022 12:00:00
137374 111 06/04/2022 12:00:00
Example Output:
user_id tweet_date rolling_avg_3days
111 06/01/2022 12:00:00 2.00
111 06/02/2022 12:00:00 1.50
111 06/04/2022 12:00:00 1.33
254 06/02/2022 12:00:00 1.00
ans-To calculate the 3-day rolling average of tweets for each user on each tweet date, you can use a self-join on the `tweets` table and calculate the average over a window of the previous three days. Here's the SQL query:

```sql
SELECT
    t1.user_id,
    t1.tweet_date,
    ROUND(AVG(COUNT(t2.tweet_id)) OVER (PARTITION BY t1.user_id ORDER BY t1.tweet_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS rolling_avg_3days
FROM tweets t1
LEFT JOIN tweets t2 ON t1.user_id = t2.user_id AND t1.tweet_date - INTERVAL '3 days' <= t2.tweet_date AND t2.tweet_date <= t1.tweet_date
GROUP BY t1.user_id, t1.tweet_date
ORDER BY t1.user_id, t1.tweet_date;
```

This query performs a self-join on the `tweets` table (`t1` and `t2`) using the `user_id` as the join condition. It calculates the rolling average over a window of the previous three days using the `AVG(COUNT(...)) OVER (...)` window function. The `LEFT JOIN` ensures that all dates are considered, even if there are gaps in the data.

The `PARTITION BY` clause in the `OVER` clause divides the data into partitions based on `user_id`, and the `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` clause defines the window for the rolling average.

Finally, the result is grouped by `user_id` and `tweet_date`, and the rolling average is rounded to two decimal places. The result is ordered by `user_id` and `tweet_date`.
Q99.
Assume we are given the tables below containing information on Snapchat users, their ages, and
their time spent sending and opening snaps. Write a query to obtain a breakdown of the time spent
sending vs. opening snaps (as a percentage of total time spent on these activities) for each age
group.
Hint- Use join and case
Output the age bucket and percentage of sending and opening snaps. Round the percentage to 2
decimal places.
Notes:
● You should calculate these percentages:
○ time sending / (time sending + time opening)
○ time opening / (time sending + time opening)
● To avoid integer division in percentages, multiply by 100.0 and not 100.
activities Table:
Column Name Type
activity_id integer
user_id integer
activity_type string ('send', 'open', 'chat')
time_spent float
activity_date datetime
activities Example Input:
activity_id user_id activity_type time_spent activity_date
7274 123 open 4.50 06/22/2022 12:00:00
2425 123 send 3.50 06/22/2022 12:00:00
1413 456 send 5.67 06/23/2022 12:00:00
1414 789 chat 11.00 06/25/2022 12:00:00
2536 456 open 3.00 06/25/2022 12:00:00
age_breakdown Table:
Column Name Type
user_id integer
age_bucket string ('21-25', '26-30', '31-25')
age_breakdown Example Input:
user_id age_bucket
123 31-35
456 26-30
789 21-25
Example Output:
age_bucket send_perc open_perc
26-30 65.40 34.60
31-35 43.75 56.25
ans-You can use the following SQL query to calculate the breakdown of time spent sending vs. opening snaps for each age group:

```sql
SELECT
    ab.age_bucket,
    ROUND(
        (SUM(CASE WHEN a.activity_type = 'send' THEN a.time_spent ELSE 0 END) /
        (SUM(a.time_spent))) * 100.0,
        2) AS send_perc,
    ROUND(
        (SUM(CASE WHEN a.activity_type = 'open' THEN a.time_spent ELSE 0 END) /
        (SUM(a.time_spent))) * 100.0,
        2) AS open_perc
FROM age_breakdown ab
JOIN activities a ON ab.user_id = a.user_id
GROUP BY ab.age_bucket;
```

This query joins the `age_breakdown` table with the `activities` table on the `user_id` field. It then calculates the percentage of time spent sending and opening snaps for each age group using the `CASE` statement within the `SUM` function. The percentages are calculated as (time sending / total time) * 100 and (time opening / total time) * 100. The `ROUND` function is used to round the percentages to two decimal places. Finally, the results are grouped by `age_bucket`.
Q100 .
The LinkedIn Creator team is looking for power creators who use their personal profile as a company
or influencer page. This means that if someone's Linkedin page has more followers than all the
companies they work for, we can safely assume that person is a Power Creator. Keep in mind that if a
person works at multiple companies, we should take into account the company with the most
followers.
Level - Medium
Hint- Use join and group by
Write a query to return the IDs of these LinkedIn power creators in ascending order.
Assumptions:
● A person can work at multiple companies.
● In the case of multiple companies, use the one with largest follower base.
personal_profiles Table:
Column Name Type
profile_id integer
name string
followers integer
personal_profiles Example Input:
profile_id name followers
1 Nick Singh 92,000
2 Zach Wilson 199,000
3 Daliana Liu 171,000
4 Ravit Jain 107,000
5 Vin Vashishta 139,000
6 Susan Wojcicki 39,000
employee_company Table:
Column Name Type
personal_profile_id integer
company_id integer
employee_company Example Input:
personal_profile_id company_id
1 4
1 9
2 2
3 1
4 3
5 6
6 5
company_pages Table:
Column Name Type
company_id integer
name string
followers integer
company_pages Example Input:
company_id name followers
1 The Data Science Podcast 8,000
2 Airbnb 700,000
3 The Ravit Show 6,000
4 DataLemur 200
5 YouTube 1,6000,000
6 DataScience.Vin 4,500
9 Ace The Data Science Interview 4479
Example Output:
profile_id
1
3
4
5
ans-we can achieve this by joining the `personal_profiles` table with the `employee_company` and `company_pages` tables, grouping by the `profile_id`, and then selecting the IDs of power creators where the followers of their personal profile are greater than the maximum followers of the companies they work for. Here's the SQL query:

```sql
SELECT pp.profile_id
FROM personal_profiles pp
JOIN employee_company ec ON pp.profile_id = ec.personal_profile_id
JOIN company_pages cp ON ec.company_id = cp.company_id
GROUP BY pp.profile_id
HAVING MAX(cp.followers) < pp.followers
ORDER BY pp.profile_id;
```

This query first joins the three tables using appropriate JOIN clauses, then groups the results by `profile_id`. The HAVING clause filters out the groups where the maximum followers of the companies (`MAX(cp.followers)`) are less than the followers of the personal profile (`pp.followers`). Finally, the result is ordered in ascending order by `profile_id`.